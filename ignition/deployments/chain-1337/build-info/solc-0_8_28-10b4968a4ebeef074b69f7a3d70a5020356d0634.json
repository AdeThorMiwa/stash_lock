{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-10b4968a4ebeef074b69f7a3d70a5020356d0634",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/implementation/OwnableOps.sol": "project/contracts/implementation/OwnableOps.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/common/Context.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Context\n/// @author AdeThorMiwa\n/// @notice This contract is an abstract base contract that provides\n///         commonly used functions for accessing message information from the current context.\n/// @dev It is intended to be inherited by other contracts that need access to\n///      `msg.sender`, `msg.data`, `msg.sig`, and `msg.value`.\nabstract contract Context {\n    /// @dev Returns the message sender address from the current context.\n    /// @return msgSender The address of the message sender.\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    /// @dev Returns the message value (in wei) of the current context.\n    /// @return msgValue The value of the message in wei.\n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}\n"
      },
      "project/contracts/common/Ownable.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {IERC173} from \"../interface/IERC173.sol\";\n\nimport {UnauthorizedAccount, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\nimport {Context} from \"./Context.sol\";\n\n/// @title Ownable\n/// @author AdeThorMiwa\n/// @notice This contract implements the Ownable standard, allowing for the\n///         management of a contract's owner.\n/// @dev This implementation is based on the EIP-173 standard: https://eips.ethereum.org/EIPS/eip-173\nabstract contract Ownable is Context, IERC173 {\n    /// @dev The address of the current contract owner.\n    address private _owner;\n\n    /// @dev A modifier that restricts function execution to the contract owner.\n    modifier onlyOwner() {\n        if (_msgSender() != _getOwner())\n            revert UnauthorizedAccount(_msgSender(), \"NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new account (`_newOwner`).\n    /// @dev This function can only be called by the current contract owner.\n    ///         Reverts if the new owner is the zero address.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        if (_newOwner == address(0)) revert ZeroAddressNotAllowed(\"NEW_OWNER\");\n        _transferOwnership(_newOwner);\n    }\n\n    /// @notice Renounces ownership of the contract by transferring it to the zero address.\n    /// @dev This function can only be called by the current contract owner.\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return address The address of the current owner.\n    function owner() external view override returns (address) {\n        return _getOwner();\n    }\n\n    /// @notice Transfers ownership of the contract to a new account Â (`_newOwner`).\n    /// @dev This is an internal function, not meant to be called directly.\n    ///      Emits an `OwnershipTransferred` event after ownership is transferred.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal virtual {\n        address _previousOwner = _getOwner();\n        _owner = _newOwner;\n        emit OwnershipTransferred(_previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the address of the current contract owner.\n    /// @dev This is an internal function, not meant to be called directly.\n    /// @return address The address of the current owner.\n    function _getOwner() internal view virtual returns (address) {\n        return _owner;\n    }\n}\n"
      },
      "project/contracts/implementation/OwnableOps.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\n\nimport {Ownable} from \"../common/Ownable.sol\";\n\n/// @title Ownable Operations Contract\n/// @author AdeThorMiwa\n/// @notice This contract extends the Ownable functionality, utilizing CommonStorage for owner management.\n/// @dev Overrides Ownable functions to use CommonStorage for storing and retrieving the owner.\ncontract OwnableOps is Ownable {\n    /// @notice Overrides the _transferOwnership function from Ownable to use CommonStorage.\n    /// @inheritdoc Ownable\n    function _transferOwnership(address _newOwner) internal override {\n        CommonStorage._setOwner(_newOwner);\n    }\n\n    /// @notice Overrides the _getOwner function from Ownable to use CommonStorage.\n    /// @inheritdoc Ownable\n    function _getOwner() internal view override returns (address) {\n        return CommonStorage._getOwner();\n    }\n}\n"
      },
      "project/contracts/interface/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC173: Contract Ownership\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC-173 Contract Ownership Standard.\n/// @dev See https://eips.ethereum.org/EIPS/eip-173 for more details.\ninterface IERC173 {\n    /// @dev Emitted when ownership of the contract is transferred.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev Setting `newOwner` to the zero address renounces ownership.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external;\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return owner The address of the contract owner.\n    function owner() external view returns (address);\n}\n"
      },
      "project/contracts/libs/CommonStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {InvalidInputData, ZeroAddressNotAllowed, UnauthorizedAccount} from \"../utils/Errors.sol\";\n\n/// @title CommonStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing common storage data.\n/// @dev This library contains functions for setting and getting various contract addresses,\n///      enforcing ownership, and managing supported interfaces.\nlibrary CommonStorage {\n    /// @dev Structure representing common storage used in the contract.\n    struct CStorage {\n        // The address of the owner, which is payable.\n        address payable owner;\n        // The address of the lookup proxy.\n        address lookupProxy;\n        // The address of the factory.\n        address factory;\n        // A mapping to track supported interfaces, using function selectors as keys and boolean values.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant COMMON_STORAGE_SLOT =\n        keccak256(\"com.stash.common.storage\");\n\n    /// @dev This emits when ownership of a contract changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Lookup proxy change event.\n    /// @param previousProxy The address of the previous proxy.\n    /// @param newProxy The address of the new proxy.\n    event LookupProxyChanged(\n        address indexed previousProxy,\n        address indexed newProxy\n    );\n\n    /// @dev Sets the factory address.\n    /// @param _factory The new factory address.\n    function _setFactory(address _factory) internal {\n        if (_factory == address(0))\n            revert ZeroAddressNotAllowed(\"PROTOCOL_FACTORY\");\n\n        CStorage storage cs = cStore();\n        cs.factory = _factory;\n    }\n\n    /// @dev Sets the contract owner.\n    /// @param _owner The new owner address.\n    function _setOwner(address _owner) internal {\n        if (_owner == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n\n        address previousOwner = _getOwner();\n        CStorage storage cs = cStore();\n        cs.owner = payable(_owner);\n        emit OwnershipTransferred(previousOwner, _owner);\n    }\n\n    /// @dev Sets the current stash lookup contract.\n    /// @param _lookupProxy The new stash lookup contract address.\n    function _setLookupProxy(address _lookupProxy) internal {\n        if (_lookupProxy == address(0))\n            revert ZeroAddressNotAllowed(\"LOOKUP_PROXY\");\n\n        address previousProxy = _getLookupProxy();\n        CStorage storage cs = cStore();\n        cs.lookupProxy = _lookupProxy;\n        emit LookupProxyChanged(previousProxy, _lookupProxy);\n    }\n\n    /// @dev Sets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @param _supported True if the interface is supported, false otherwise.\n    function _setSupportedInterface(\n        bytes4 _interfaceId,\n        bool _supported\n    ) internal {\n        if (_interfaceId == bytes4(0))\n            revert InvalidInputData(\"_interfaceId\", \"INVALID_LENGTH\");\n\n        CStorage storage cs = cStore();\n        cs.supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    /// @dev Gets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @return supported True if the interface is supported, false otherwise.\n    function _getSupportedInterface(\n        bytes4 _interfaceId\n    ) internal view returns (bool supported) {\n        supported = cStore().supportedInterfaces[_interfaceId];\n    }\n\n    /// @dev Gets the current stash lookup contract.\n    /// @return lookupProxy The current stash lookup address.\n    function _getLookupProxy() internal view returns (address lookupProxy) {\n        lookupProxy = cStore().lookupProxy;\n    }\n\n    /// @dev Ensures the message sender is the current contract owner.\n    function enforceIsOwner() internal view {\n        if (msg.sender != _getOwner())\n            revert UnauthorizedAccount(msg.sender, \"NOT_OWNER\");\n    }\n\n    /// @dev Gets contract owner.\n    /// @return owner The address of the owner.\n    function _getOwner() internal view returns (address owner) {\n        owner = cStore().owner;\n    }\n\n    /// @dev Gets the factory contract Address.\n    /// @return factory The address of the factory contract.\n    function _getFactory() internal view returns (address factory) {\n        factory = cStore().factory;\n    }\n\n    /// @dev Retrieves the storage structure.\n    /// @return sc The storage structure.\n    function cStore() internal pure returns (CStorage storage sc) {\n        bytes32 pos = COMMON_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sc.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}