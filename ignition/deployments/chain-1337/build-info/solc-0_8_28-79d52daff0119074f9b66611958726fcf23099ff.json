{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-79d52daff0119074f9b66611958726fcf23099ff",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/FactoryProxy.sol": "project/contracts/FactoryProxy.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "project/contracts/common/ERC1967Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {Proxy} from \"./Proxy.sol\";\nimport {ERC1967Upgrade} from \"./ERC1967Upgrade.sol\";\n\n/// @title ERC1967 Proxy\n/// @notice Implements a proxy contract based on the ERC1967 upgradeable proxy standard.\n/// @dev This contract acts as a proxy for delegating calls to an implementation contract.\n///      It supports upgrades using the ERC1967 upgrade mechanism.\nabstract contract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /// @dev Initializes an ERC1967 proxy with a given implementation contract and optional initialization data.\n    ///\n    /// Deploys the proxy and calls the `_upgradeToAndCall` function of the ERC1967Upgrade\n    /// contract to set the initial implementation and optionally execute data.\n    ///\n    /// Requirements:\n    /// - `_logic` must be a non-zero address.\n    constructor(address _logic, bytes memory _data) payable {\n        assert(\n            _IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _upgradeToAndCall(_logic, _data);\n    }\n\n    /// @dev Returns the current implementation address stored in this proxy.\n    ///\n    /// This function is an internal implementation detail and should generally not be used\n    /// directly by user applications.\n    function _implementation()\n        internal\n        view\n        virtual\n        override\n        returns (address impl)\n    {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
      },
      "project/contracts/common/ERC1967Upgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity 0.8.28;\n\nimport {StorageSlot} from \"../libs/StorageSlot.sol\";\nimport {CheckAddress} from \"../libs/CheckAddress.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {NotContractAddress, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\n\n/// @dev This abstract contract provides functionalities for managing storage slots\n/// used by the ERC1967 Upgradeable Proxy standard (EIP-1967).\n/// It includes functions for getting and setting the implementation address\n/// and the admin address.\n/// _Available since v4.1._\n/// @custom:oz-upgrades-unsafe-allow delegatecall\nabstract contract ERC1967Upgrade {\n    using Address for address;\n    using CheckAddress for address;\n\n    /// @dev Storage slot with the address of the current implementation.\n    /// This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev Emitted when the admin account has changed.\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\n\n    /// @dev Emitted when the implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev Perform implementation upgrade\n    /// Emits an {Upgraded} event.\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /// @dev Perform implementation upgrade with additional setup call.\n    /// Emits an {Upgraded} event.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0) {\n            newImplementation.functionDelegateCall(data);\n        }\n    }\n\n    /// @notice Changes the admin of the proxy.\n    /// @dev Emits an {AdminChanged} event.\n    function _changeAdmin(address newAdmin) internal {\n        _setAdmin(newAdmin);\n        emit AdminChanged(_getAdmin(), newAdmin);\n    }\n\n    /// @dev Returns the current implementation address.\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /// @dev Returns the current admin.\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /// @dev Stores a new address in the EIP1967 admin slot.\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0))\n            revert ZeroAddressNotAllowed(\"ADMIN_ADDRESS\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /// @dev Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        if (!newImplementation.hasContractCode())\n            revert NotContractAddress(newImplementation);\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n}\n"
      },
      "project/contracts/common/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.28;\n\n/// @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n///       instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n///       be specified by overriding the virtual {_implementation} function.\n///       Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n///       different contract through the {_delegate} function.\n///       The success and return data of the delegated call will be returned back to the caller of the proxy.\nabstract contract Proxy {\n    /// @dev Fallback function that delegates calls to the address returned by `_implementation()`.\n    ///      Will run if call data is empty.\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /// @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n    ///     function in the contract matches the call data.\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /// @dev Delegates the current call to the address returned by `_implementation()`.\n    ///     This function does not return to its internall call site, it will return directly to the external caller.\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /// @notice Delegates the current call to `implementation`.\n    /// @dev This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n    ///      call, or as part of the Solidity `fallback` or `receive` functions.\n    ///      If overriden should call `super._beforeFallback()`.\n    // solhint-disable-next-line no-empty-blocks\n    function _beforeFallback() internal virtual {}\n\n    /// @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n    ///      and {_fallback} should delegate.\n    function _implementation() internal view virtual returns (address);\n}\n"
      },
      "project/contracts/FactoryProxy.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"./interface/IERC165.sol\";\nimport {IERC173} from \"./interface/IERC173.sol\";\n\nimport {CommonStorage} from \"./libs/CommonStorage.sol\";\nimport {FactoryStorage} from \"./libs/FactoryStorage.sol\";\n\nimport {UpgradeableProxy} from \"./upgrade/UpgradeableProxy.sol\";\n\n/// @title Factory Proxy Contract\n/// @author AdeThorMiwa\n/// @notice This contract handles the proxy functionality for the stash factory, allowing for upgrades and initialization.\n/// @dev Extends the `UpgradeableProxy` contract and registers contract implementation on initiation.\ncontract FactoryProxy is UpgradeableProxy {\n    /// @notice Constructs the stash factory proxy contract\n    /// @dev Initializes the factory proxy with the provided parameters and sets up supported interfaces.\n    /// @param owner Factory contract proxy owner address\n    /// @param proxyAdmin Factory proxy admin address\n    /// @param implementation Factory implementation contract address\n    /// @param stashLookup Stash lookup contract address\n    /// @param userMaxStash user stash limit\n    constructor(\n        address owner,\n        address proxyAdmin,\n        address implementation,\n        address stashLookup,\n        uint16 userMaxStash\n    ) UpgradeableProxy(implementation, proxyAdmin) {\n        CommonStorage._setOwner(owner);\n        CommonStorage._setLookupProxy(stashLookup);\n        FactoryStorage._setUserMaxStash(userMaxStash);\n\n        CommonStorage._setSupportedInterface(type(IERC165).interfaceId, true);\n        CommonStorage._setSupportedInterface(type(IERC173).interfaceId, true);\n    }\n}\n"
      },
      "project/contracts/interface/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC165\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC165 standard.\n/// @dev This interface allows contracts to declare and query support for specific interfaces.\ninterface IERC165 {\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// @param interfaceId The interface identifier, as specified in ERC-165.\n    /// @return True if the contract implements the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/interface/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC173: Contract Ownership\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC-173 Contract Ownership Standard.\n/// @dev See https://eips.ethereum.org/EIPS/eip-173 for more details.\ninterface IERC173 {\n    /// @dev Emitted when ownership of the contract is transferred.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev Setting `newOwner` to the zero address renounces ownership.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external;\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return owner The address of the contract owner.\n    function owner() external view returns (address);\n}\n"
      },
      "project/contracts/libs/CheckAddress.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckAddress Library\n/// @author AdeThorMiwa\n/// @notice Provides utility functions for address type, particularly to check if an address is a contract.\n/// @dev This library contains a function to determine if an address has associated contract code.\nlibrary CheckAddress {\n    /// @dev Checks if an address has associated contract code.\n    /// @param _address The address to check for contract code.\n    /// @return bool indicating whether the address has contract code.\n    function hasContractCode(address _address) internal view returns (bool) {\n        uint256 _codeSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _codeSize := extcodesize(_address)\n        }\n        return _codeSize > 0;\n    }\n}\n"
      },
      "project/contracts/libs/CommonStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {InvalidInputData, ZeroAddressNotAllowed, UnauthorizedAccount} from \"../utils/Errors.sol\";\n\n/// @title CommonStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing common storage data.\n/// @dev This library contains functions for setting and getting various contract addresses,\n///      enforcing ownership, and managing supported interfaces.\nlibrary CommonStorage {\n    /// @dev Structure representing common storage used in the contract.\n    struct CStorage {\n        // The address of the owner, which is payable.\n        address payable owner;\n        // The address of the lookup proxy.\n        address lookupProxy;\n        // The address of the factory.\n        address factory;\n        // A mapping to track supported interfaces, using function selectors as keys and boolean values.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant COMMON_STORAGE_SLOT =\n        keccak256(\"com.stash.common.storage\");\n\n    /// @dev This emits when ownership of a contract changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Lookup proxy change event.\n    /// @param previousProxy The address of the previous proxy.\n    /// @param newProxy The address of the new proxy.\n    event LookupProxyChanged(\n        address indexed previousProxy,\n        address indexed newProxy\n    );\n\n    /// @dev Sets the factory address.\n    /// @param _factory The new factory address.\n    function _setFactory(address _factory) internal {\n        if (_factory == address(0))\n            revert ZeroAddressNotAllowed(\"PROTOCOL_FACTORY\");\n\n        CStorage storage cs = cStore();\n        cs.factory = _factory;\n    }\n\n    /// @dev Sets the contract owner.\n    /// @param _owner The new owner address.\n    function _setOwner(address _owner) internal {\n        if (_owner == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n\n        address previousOwner = _getOwner();\n        CStorage storage cs = cStore();\n        cs.owner = payable(_owner);\n        emit OwnershipTransferred(previousOwner, _owner);\n    }\n\n    /// @dev Sets the current stash lookup contract.\n    /// @param _lookupProxy The new stash lookup contract address.\n    function _setLookupProxy(address _lookupProxy) internal {\n        if (_lookupProxy == address(0))\n            revert ZeroAddressNotAllowed(\"LOOKUP_PROXY\");\n\n        address previousProxy = _getLookupProxy();\n        CStorage storage cs = cStore();\n        cs.lookupProxy = _lookupProxy;\n        emit LookupProxyChanged(previousProxy, _lookupProxy);\n    }\n\n    /// @dev Sets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @param _supported True if the interface is supported, false otherwise.\n    function _setSupportedInterface(\n        bytes4 _interfaceId,\n        bool _supported\n    ) internal {\n        if (_interfaceId == bytes4(0))\n            revert InvalidInputData(\"_interfaceId\", \"INVALID_LENGTH\");\n\n        CStorage storage cs = cStore();\n        cs.supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    /// @dev Gets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @return supported True if the interface is supported, false otherwise.\n    function _getSupportedInterface(\n        bytes4 _interfaceId\n    ) internal view returns (bool supported) {\n        supported = cStore().supportedInterfaces[_interfaceId];\n    }\n\n    /// @dev Gets the current stash lookup contract.\n    /// @return lookupProxy The current stash lookup address.\n    function _getLookupProxy() internal view returns (address lookupProxy) {\n        lookupProxy = cStore().lookupProxy;\n    }\n\n    /// @dev Ensures the message sender is the current contract owner.\n    function enforceIsOwner() internal view {\n        if (msg.sender != _getOwner())\n            revert UnauthorizedAccount(msg.sender, \"NOT_OWNER\");\n    }\n\n    /// @dev Gets contract owner.\n    /// @return owner The address of the owner.\n    function _getOwner() internal view returns (address owner) {\n        owner = cStore().owner;\n    }\n\n    /// @dev Gets the factory contract Address.\n    /// @return factory The address of the factory contract.\n    function _getFactory() internal view returns (address factory) {\n        factory = cStore().factory;\n    }\n\n    /// @dev Retrieves the storage structure.\n    /// @return sc The storage structure.\n    function cStore() internal pure returns (CStorage storage sc) {\n        bytes32 pos = COMMON_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sc.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/FactoryStorage.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title FactoryStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing factory-related storage data.\n/// @dev This library contains functions for managing stash and user account limits.\nlibrary FactoryStorage {\n    /// @dev Factory storage structure.\n    struct FStorage {\n        // The maximum number of stash allowed to be created by a single user.\n        uint16 userMaxStash;\n        // Mapping indicating whether an address is a stash.\n        mapping(address => bool) isStash;\n        // Mapping of user addresses to their stashes.\n        mapping(address => address[]) stashes;\n    }\n\n    /// @dev Random storage slot for factory storage.\n    bytes32 internal constant FACTORY_STORAGE_SLOT =\n        keccak256(\"com.stash.factory.storage\");\n\n    /// @dev Sets the allowed maximum number of user stash.\n    /// @param _limit The maximum user stash limit.\n    function _setUserMaxStash(uint16 _limit) internal {\n        FStorage storage fs = _store();\n        fs.userMaxStash = _limit;\n    }\n\n    /// @dev Adds a stash for an owner.\n    /// @param _owner The owner's address.\n    /// @param _stashAddress The stash address.\n    /// @param _stashIndex The index of the stash.\n    function _addStash(\n        address _owner,\n        address _stashAddress,\n        uint256 _stashIndex\n    ) internal {\n        FStorage storage fs = _store();\n        fs.stashes[_owner].push();\n        fs.stashes[_owner][_stashIndex] = _stashAddress;\n        fs.isStash[_stashAddress] = true;\n    }\n\n    /// @dev Checks if an address is a registered stash.\n    /// @param _stash The address to check.\n    /// @return True if the address is a registered stash, false otherwise.\n    function _isStash(address _stash) internal view returns (bool) {\n        return _store().isStash[_stash];\n    }\n\n    /// @dev Gets the allowed maximum number of user stash.\n    /// @return maxStash The allowed maximum number of user stash.\n    function _getUserStashLimit() internal view returns (uint16 maxStash) {\n        maxStash = _store().userMaxStash;\n    }\n\n    /// @dev Gets the stash associated with a owner.\n    /// @param _ownerAddress The owner's address.\n    /// @return stashes The list of stash accounts.\n    /// @return currentCount The current number of stash accounts.\n    function _getStashes(\n        address _ownerAddress\n    ) internal view returns (address[] memory stashes, uint256 currentCount) {\n        stashes = _store().stashes[_ownerAddress];\n        currentCount = stashes.length;\n    }\n\n    /// @dev Returns storage value from designated slot.\n    /// @return fs The factory storage structure.\n    function _store() internal pure returns (FStorage storage fs) {\n        bytes32 pos = FACTORY_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            fs.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/StorageSlot.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title StorageSlot Library\n/// @author AdeThorMiwa\n/// @notice Library for managing value storage slots\n/// @dev Provides functions to work with specific storage slots. Useful for reading and writing to contract storage slots directly.\n// solhint-disable no-inline-assembly\nlibrary StorageSlot {\n    /// @dev Struct to represent an address storage slot.\n    struct AddressSlot {\n        // The address value stored at the slot.\n        address value;\n    }\n\n    /// @notice Returns an `AddressSlot` with member `value` located at `slot`.\n    /// @param slot The storage slot to read from.\n    /// @return r The `AddressSlot` with the value located at `slot`.\n    function getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
      },
      "project/contracts/upgrade/UpgradeableProxy.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {ZeroAddressNotAllowed, ActionRejected, InvalidInputData} from \"../utils/Errors.sol\";\nimport {ERC1967Proxy} from \"../common/ERC1967Proxy.sol\";\n\n/// @title UpgradeableProxy Contract\n/// @author AdeThorMiwa\n/// @notice This contract implements an upgradeable proxy that uses the ERC1967 standard.\n/// @dev It includes functions to upgrade the implementation and manage the admin role.\nabstract contract UpgradeableProxy is ERC1967Proxy {\n    /// @dev Modifier used internally to delegate the call to the implementation unless the sender is the admin.\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /// @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n    ///     Optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n    /// @param _logic The address of the initial implementation.\n    /// @param admin_ The address of the admin.\n    constructor(\n        address _logic,\n        address admin_\n    ) ERC1967Proxy(_logic, bytes(\"\")) {\n        assert(\n            _ADMIN_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _changeAdmin(admin_);\n    }\n\n    /// @dev Returns the current admin address.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-getProxyAdmin}\n    /// TIP: To get this value, clients can read directly from the storage slot specified by EIP1967 using the `eth_getStorageAt` RPC call.\n    /// @return admin_ The address of the current admin.\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /// @dev Returns the current implementation address.\n    /// Requirements:\n    /// - Only the admin can call this function.\n    /// TIP: To get this value, clients can read directly from the storage slot specified by EIP1967 using the `eth_getStorageAt` RPC call.\n    /// @return implementation_ The address of the current implementation.\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementation_)\n    {\n        implementation_ = _implementation();\n    }\n\n    /// @dev Changes the admin of the proxy to `newAdmin`.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-FactoryProxyAdmin}.\n    /// - `newAdmin` cannot be the zero address.\n    /// Emits an {AdminChanged} event.\n    /// @param newAdmin The address of the new admin.\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        if (address(newAdmin) == address(0))\n            revert ZeroAddressNotAllowed(\"NEW_ADMIN\");\n        _changeAdmin(newAdmin);\n    }\n\n    /// @dev Upgrade the implementation of the proxy to `newImplementation`.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-upgrade}.\n    /// - `newImplementation` cannot be the zero address.\n    /// @param newImplementation The address of the new implementation.\n    function upgradeTo(address newImplementation) external ifAdmin {\n        if (address(newImplementation) == address(0))\n            revert ZeroAddressNotAllowed(\"IMPLEMENTATION\");\n        _upgradeToAndCall(newImplementation, bytes(\"\"));\n    }\n\n    /// @dev Upgrade the implementation of the proxy to `newImplementation` and call a function from the new implementation.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-upgradeAndCall}.\n    /// - `newImplementation` cannot be the zero address.\n    /// @param newImplementation The address of the new implementation.\n    /// @param data The data to call the new implementation with.\n\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes calldata data\n    ) external payable ifAdmin {\n        if (data.length == 0) revert InvalidInputData(\"data\", \"ZERO_BYTES\");\n        if (address(newImplementation) == address(0))\n            revert ZeroAddressNotAllowed(\"IMPLEMENTATION\");\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    /// @dev Ensures the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n    /// Requirements:\n    /// - If the sender is the admin, revert with `ActionRejected`.\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin())\n            revert ActionRejected(\"UPGRADABLE_PROXY: ADMIN_FALLBACK\");\n        super._beforeFallback();\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}