{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-ce61d79e8d4d6d2cbe75fcf89a5fa95d63674900",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/implementation/StashOps.sol": "project/contracts/implementation/StashOps.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/common/Context.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Context\n/// @author AdeThorMiwa\n/// @notice This contract is an abstract base contract that provides\n///         commonly used functions for accessing message information from the current context.\n/// @dev It is intended to be inherited by other contracts that need access to\n///      `msg.sender`, `msg.data`, `msg.sig`, and `msg.value`.\nabstract contract Context {\n    /// @dev Returns the message sender address from the current context.\n    /// @return msgSender The address of the message sender.\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    /// @dev Returns the message value (in wei) of the current context.\n    /// @return msgValue The value of the message in wei.\n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}\n"
      },
      "project/contracts/common/StashBase.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {SCSStorage} from \"../libs/SCSStorage.sol\";\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\n\nimport {ActionRejected} from \"../utils/Errors.sol\";\nimport {Context} from \"./Context.sol\";\nimport {UseOwner} from \"../common/UseOwner.sol\";\n\n/// @title StashBase\n/// @author AdeThorMiwa\n/// @notice Abstract base contract providing core functionalities for stash contracts.\n/// @dev This contract defines common modifiers for stash-related operations\n///      It also inherits from `Context` and `UseOwner` for basic functionalities.\nabstract contract StashBase is Context, UseOwner {\n\n}\n"
      },
      "project/contracts/common/UseOwner.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\n\n/// @title UseOwner\n/// @author AdeThorMiwa\n/// @notice Abstract contract providing an onlyOwner modifier for access control.\n/// @dev This contract leverages the CommonStorage library to enforce ownership checks.\nabstract contract UseOwner {\n    /// @notice Modifier restricting function calls to the contract owner.\n    /// @dev Reverts with an `UnauthorizedAccount` error if the caller is not the owner.\n    modifier onlyOwner() {\n        CommonStorage.enforceIsOwner();\n        _;\n    }\n}\n"
      },
      "project/contracts/common/UseValue.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {CheckCallResult} from \"../libs/CheckCallResult.sol\";\n\nimport {NotEnoughBalance} from \"../utils/Errors.sol\";\n\n/// @title UseValue\n/// @author AdeThorMiwa\n/// @notice Abstract contract providing utility functions for handling native Ether.\n/// @dev This contract offers functions to retrieve the contract's Ether balance using\n///      `selfBalance()` and send Ether to external addresses using `sendValue()`.\nabstract contract UseValue {\n    using CheckCallResult for bool;\n\n    /// @dev Sends Ether to a specified recipient address.\n    /// @param _recipient The address to receive the Ether.\n    /// @param _value The amount of Ether to send.\n    /// @dev Reverts with `NotEnoughBalance` if the contract's balance is insufficient.\n    function sendValue(address _recipient, uint256 _value) internal virtual {\n        if (selfBalance() < _value) {\n            revert NotEnoughBalance(\n                address(this),\n                _recipient,\n                selfBalance(),\n                _value,\n                address(0)\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = payable(_recipient).call{\n            value: _value\n        }(\"\");\n\n        success.verifyCallResult(returnData, \"SEND_VALUE_FAILED\");\n    }\n\n    /// @dev Returns the contract's native Ether balance.\n    /// @return _balance The amount of Ether held by the contract.\n    function selfBalance() internal view virtual returns (uint256 _balance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _balance := selfbalance()\n        }\n    }\n}\n"
      },
      "project/contracts/implementation/StashOps.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IStashOps} from \"../interface/IStashOps.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {SCSStorage} from \"../libs/SCSStorage.sol\";\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\nimport {Types} from \"../libs/Types.sol\";\n\nimport {ActionRejected} from \"../utils/Errors.sol\";\nimport {StashBase} from \"../common/StashBase.sol\";\nimport {UseValue} from \"../common/UseValue.sol\";\n\n/// @title StashOps\n/// @author AdeThorMiwa\n/// @notice Manages operations related to stash.\n/// @dev Includes functionalities to manage and interact with stash operations.\ncontract StashOps is UseValue, StashBase, IStashOps {\n    using SafeERC20 for IERC20;\n\n    /// @notice Retrieves the stash balance for native coin.\n    /// @dev Fetches native balance from SCSStorage.\n    /// @inheritdoc IStashOps\n    function balance() external view returns (uint256) {\n        return SCSStorage._balance();\n    }\n\n    /// @notice Retrieves the stash balance for an ERC20 token\n    /// @dev Fetches ERC20 token balance from SCSStorage.\n    /// @inheritdoc IStashOps\n    function balance(IERC20 _token) external view returns (uint256) {\n        return SCSStorage._balance(_token);\n    }\n\n    /// @notice Sets the stash state to enable or disable owner action.\n    /// @dev Only callable by the owner. Emits StashStatusChanged event.\n    /// @inheritdoc IStashOps\n    function setStatus(Types.StashStatus _status) external override onlyOwner {\n        SCSStorage._setStatus(_status);\n        emit StashStatusChanged(address(this), _status);\n    }\n\n    function getStatus() external view returns (Types.StashStatus status) {\n        status = SCSStorage._status();\n    }\n\n    /// @notice Checks if a specific interface is supported.\n    /// @dev Verifies the supported interface in CommonStorage.\n    /// @param _interfaceId The interface identifier to check.\n    /// @return bool True if the interface is supported, otherwise false.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view returns (bool) {\n        return CommonStorage._getSupportedInterface(_interfaceId);\n    }\n}\n"
      },
      "project/contracts/interface/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC165\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC165 standard.\n/// @dev This interface allows contracts to declare and query support for specific interfaces.\ninterface IERC165 {\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// @param interfaceId The interface identifier, as specified in ERC-165.\n    /// @return True if the contract implements the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/interface/IStashOps.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {Types} from \"../libs/Types.sol\";\n\n/// @title IStashOps\n/// @author AdeThorMiwa\n/// @notice Interface for stash account operations.\n/// @dev Defines functions for managing stash accounts, including\n///     managing, and querying stash information.\ninterface IStashOps is IERC165 {\n    event StashStatusChanged(address indexed stash, Types.StashStatus status);\n\n    function balance() external view returns (uint256);\n\n    function balance(IERC20 token) external view returns (uint256);\n\n    function setStatus(Types.StashStatus _status) external;\n\n    function getStatus() external view returns (Types.StashStatus status);\n}\n"
      },
      "project/contracts/libs/CheckCallResult.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckCallResult Library\n/// @author AdeThorMiwa\n/// @notice Provides a utility function to verify the result of a low-level call and revert if it fails.\n/// @dev This library contains a function to verify the success of a low-level call and handle the returned data or revert with an error message.\nlibrary CheckCallResult {\n    /// @dev Verifies the result of a low-level call.\n    /// @param _success A boolean indicating the success of the call.\n    /// @param _returnData The data returned from the call.\n    /// @param _errMessage The error message to revert with if the call failed and no return data is provided.\n    /// @return bytes The data returned from the call if it was successful.\n    function verifyCallResult(\n        bool _success,\n        bytes memory _returnData,\n        string memory _errMessage\n    ) internal pure returns (bytes memory) {\n        if (_success) {\n            return _returnData;\n        } else {\n            if (_returnData.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returnDataSize := mload(_returnData)\n                    revert(add(32, _returnData), returnDataSize)\n                }\n            } else {\n                revert(_errMessage);\n            }\n        }\n    }\n}\n"
      },
      "project/contracts/libs/CommonStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {InvalidInputData, ZeroAddressNotAllowed, UnauthorizedAccount} from \"../utils/Errors.sol\";\n\n/// @title CommonStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing common storage data.\n/// @dev This library contains functions for setting and getting various contract addresses,\n///      enforcing ownership, and managing supported interfaces.\nlibrary CommonStorage {\n    /// @dev Structure representing common storage used in the contract.\n    struct CStorage {\n        // The address of the owner, which is payable.\n        address payable owner;\n        // The address of the lookup proxy.\n        address lookupProxy;\n        // The address of the factory.\n        address factory;\n        // A mapping to track supported interfaces, using function selectors as keys and boolean values.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant COMMON_STORAGE_SLOT =\n        keccak256(\"com.stash.common.storage\");\n\n    /// @dev This emits when ownership of a contract changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Lookup proxy change event.\n    /// @param previousProxy The address of the previous proxy.\n    /// @param newProxy The address of the new proxy.\n    event LookupProxyChanged(\n        address indexed previousProxy,\n        address indexed newProxy\n    );\n\n    /// @dev Sets the factory address.\n    /// @param _factory The new factory address.\n    function _setFactory(address _factory) internal {\n        if (_factory == address(0))\n            revert ZeroAddressNotAllowed(\"PROTOCOL_FACTORY\");\n\n        CStorage storage cs = cStore();\n        cs.factory = _factory;\n    }\n\n    /// @dev Sets the contract owner.\n    /// @param _owner The new owner address.\n    function _setOwner(address _owner) internal {\n        if (_owner == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n\n        address previousOwner = _getOwner();\n        CStorage storage cs = cStore();\n        cs.owner = payable(_owner);\n        emit OwnershipTransferred(previousOwner, _owner);\n    }\n\n    /// @dev Sets the current stash lookup contract.\n    /// @param _lookupProxy The new stash lookup contract address.\n    function _setLookupProxy(address _lookupProxy) internal {\n        if (_lookupProxy == address(0))\n            revert ZeroAddressNotAllowed(\"LOOKUP_PROXY\");\n\n        address previousProxy = _getLookupProxy();\n        CStorage storage cs = cStore();\n        cs.lookupProxy = _lookupProxy;\n        emit LookupProxyChanged(previousProxy, _lookupProxy);\n    }\n\n    /// @dev Sets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @param _supported True if the interface is supported, false otherwise.\n    function _setSupportedInterface(\n        bytes4 _interfaceId,\n        bool _supported\n    ) internal {\n        if (_interfaceId == bytes4(0))\n            revert InvalidInputData(\"_interfaceId\", \"INVALID_LENGTH\");\n\n        CStorage storage cs = cStore();\n        cs.supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    /// @dev Gets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @return supported True if the interface is supported, false otherwise.\n    function _getSupportedInterface(\n        bytes4 _interfaceId\n    ) internal view returns (bool supported) {\n        supported = cStore().supportedInterfaces[_interfaceId];\n    }\n\n    /// @dev Gets the current stash lookup contract.\n    /// @return lookupProxy The current stash lookup address.\n    function _getLookupProxy() internal view returns (address lookupProxy) {\n        lookupProxy = cStore().lookupProxy;\n    }\n\n    /// @dev Ensures the message sender is the current contract owner.\n    function enforceIsOwner() internal view {\n        if (msg.sender != _getOwner())\n            revert UnauthorizedAccount(msg.sender, \"NOT_OWNER\");\n    }\n\n    /// @dev Gets contract owner.\n    /// @return owner The address of the owner.\n    function _getOwner() internal view returns (address owner) {\n        owner = cStore().owner;\n    }\n\n    /// @dev Gets the factory contract Address.\n    /// @return factory The address of the factory contract.\n    function _getFactory() internal view returns (address factory) {\n        factory = cStore().factory;\n    }\n\n    /// @dev Retrieves the storage structure.\n    /// @return sc The storage structure.\n    function cStore() internal pure returns (CStorage storage sc) {\n        bytes32 pos = COMMON_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sc.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/SCSStorage.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Types} from \"../libs/Types.sol\";\n\n/// @title SCSStorage\n/// @author AdeThorMiwa\n/// @notice Library for managing storage and operations related to Smart Contract Stash (SCS)\n/// @dev Contains functions for enforcing access control\nlibrary SCSStorage {\n    /// @dev stash primary storage\n    struct SPStorage {\n        // Lookup address\n        address lookupAddress;\n        // list of tokens that has been deposited in this stash\n        IERC20[] tokens;\n        // status of the stash\n        Types.StashStatus status;\n        // balances of stash\n        mapping(IERC20 => uint256) balances;\n    }\n\n    /// @dev Storage slot for SCS storage\n    bytes32 internal constant SCS_STORAGE_SLOT =\n        keccak256(\"com.stash.scs.storage\");\n\n    function _setStatus(Types.StashStatus status) internal {\n        SPStorage storage sps = _store();\n        sps.status = status;\n    }\n\n    /// @dev Return the contract's balance of the network coin\n    /// @return balance The balance of the network coin\n    function _balance() internal view returns (uint256) {\n        return selfBalance();\n    }\n\n    /// @dev Return the contract's balance of a specific ERC20 token\n    /// @param _token The ERC20 token address\n    /// @return balance The balance of the token\n    function _balance(IERC20 _token) internal view returns (uint256) {\n        return _token.balanceOf(address(this));\n    }\n\n    function _status() internal view returns (Types.StashStatus) {\n        return _store().status;\n    }\n\n    /// @dev Use selfbalance instead of address(this).balance\n    /// @return __balance The balance of the contract\n    function selfBalance() internal view returns (uint256 __balance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            __balance := selfbalance()\n        }\n    }\n\n    /// @dev Returns storage from the defined slot\n    /// @return sps The storage object\n    function _store() internal pure returns (SPStorage storage sps) {\n        bytes32 pos = SCS_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sps.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/Types.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Types Library\n/// @author AdeThorMiwa\n/// @notice Library to hold re-usable custom types\n/// @dev Declare re-usable enums and structs\nlibrary Types {\n    /// @dev Enum to represent the type of action to be taken on a facet cut.\n    enum FacetCutAction {\n        ADD, // 0: Add a new facet.\n        REPLACE, // 1: Replace an existing facet.\n        REMOVE // 2: Remove a facet.\n    }\n\n    /// @dev Struct to represent a cut on a facet.\n    struct FacetCut {\n        //The address of the facet.\n        address facetAddress;\n        // The action to be taken on the facet.\n        FacetCutAction action;\n        // The list of function selectors for the facet.\n        bytes4[] functionSelector;\n    }\n\n    /// @dev Struct to represent client arguments.\n    struct ClientArgs {\n        // The address of the client.\n        address client;\n    }\n\n    enum StashStatus {\n        OPEN,\n        CLOSED\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}