{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5a91c7a4730f66db69e88bcb4f5c6708e027f336",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/implementation/LookupOps.sol": "project/contracts/implementation/LookupOps.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "project/contracts/common/Context.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Context\n/// @author AdeThorMiwa\n/// @notice This contract is an abstract base contract that provides\n///         commonly used functions for accessing message information from the current context.\n/// @dev It is intended to be inherited by other contracts that need access to\n///      `msg.sender`, `msg.data`, `msg.sig`, and `msg.value`.\nabstract contract Context {\n    /// @dev Returns the message sender address from the current context.\n    /// @return msgSender The address of the message sender.\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    /// @dev Returns the message value (in wei) of the current context.\n    /// @return msgValue The value of the message in wei.\n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}\n"
      },
      "project/contracts/common/Ownable.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {IERC173} from \"../interface/IERC173.sol\";\n\nimport {UnauthorizedAccount, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\nimport {Context} from \"./Context.sol\";\n\n/// @title Ownable\n/// @author AdeThorMiwa\n/// @notice This contract implements the Ownable standard, allowing for the\n///         management of a contract's owner.\n/// @dev This implementation is based on the EIP-173 standard: https://eips.ethereum.org/EIPS/eip-173\nabstract contract Ownable is Context, IERC173 {\n    /// @dev The address of the current contract owner.\n    address private _owner;\n\n    /// @dev A modifier that restricts function execution to the contract owner.\n    modifier onlyOwner() {\n        if (_msgSender() != _getOwner())\n            revert UnauthorizedAccount(_msgSender(), \"NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new account (`_newOwner`).\n    /// @dev This function can only be called by the current contract owner.\n    ///         Reverts if the new owner is the zero address.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        if (_newOwner == address(0)) revert ZeroAddressNotAllowed(\"NEW_OWNER\");\n        _transferOwnership(_newOwner);\n    }\n\n    /// @notice Renounces ownership of the contract by transferring it to the zero address.\n    /// @dev This function can only be called by the current contract owner.\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return address The address of the current owner.\n    function owner() external view override returns (address) {\n        return _getOwner();\n    }\n\n    /// @notice Transfers ownership of the contract to a new account Â (`_newOwner`).\n    /// @dev This is an internal function, not meant to be called directly.\n    ///      Emits an `OwnershipTransferred` event after ownership is transferred.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal virtual {\n        address _previousOwner = _getOwner();\n        _owner = _newOwner;\n        emit OwnershipTransferred(_previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the address of the current contract owner.\n    /// @dev This is an internal function, not meant to be called directly.\n    /// @return address The address of the current owner.\n    function _getOwner() internal view virtual returns (address) {\n        return _owner;\n    }\n}\n"
      },
      "project/contracts/implementation/LookupOps.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {ILookup} from \"../interface/ILookup.sol\";\nimport {IDiamondCut, Types} from \"../interface/IDiamondCut.sol\";\n\nimport {LookupStorage, CheckAddress} from \"../libs/LookupStorage.sol\";\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\n\nimport {InvalidLookupImplementation, NotContractAddress, InvalidImplementationLockKey} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../common/Ownable.sol\";\n\n/// @title LookupOps Contract\n/// @author AdeThorMiwa\n/// @notice This contract manages lookup operations for implementations, including the diamond cut process and implementation locking.\n/// @dev Lookup is based on function signature mapping to implementation contract\ncontract LookupOps is Ownable, ILookup, IDiamondCut {\n    using CheckAddress for address;\n\n    /// @notice Locks an implementation to a specific contract identifier.\n    /// @dev Reverts if the implementation does not have contract code or if the lock key is zero.\n    /// @param _implementation The implementation address to lock.\n    /// @param _lockKey The lock key to use.\n    function lockImplementation(\n        address _implementation,\n        bytes8 _lockKey\n    ) external override onlyOwner {\n        if (!_implementation.hasContractCode())\n            revert NotContractAddress(_implementation);\n        if (_lockKey == bytes8(0))\n            revert InvalidImplementationLockKey(_lockKey);\n        LookupStorage._setLockState(_implementation, true);\n        LookupStorage._setLockKey(_implementation, _lockKey);\n    }\n\n    /// @notice Sets global use support for an implementation.\n    /// @dev Reverts if the implementation does not have contract code.\n    /// @param _implementation The implementation address to update.\n    /// @param _allowGlobal True to allow global use, false otherwise.\n    function setGlobalUse(\n        address _implementation,\n        bool _allowGlobal\n    ) external override onlyOwner {\n        if (!_implementation.hasContractCode())\n            revert NotContractAddress(_implementation);\n        LookupStorage._setGlobalState(_implementation, _allowGlobal);\n    }\n\n    /// @notice Registers an array of facet cuts (implementations) for the diamond cut.\n    /// @dev This function handles the diamond cut and emits a DiamondCut event.\n    /// @param _diamondCut An array of facet cuts to apply.\n    function diamondCut(\n        Types.FacetCut[] calldata _diamondCut\n    ) external override onlyOwner {\n        LookupStorage._handleDiamondCut(_diamondCut);\n        emit DiamondCut(_diamondCut, address(0), \"\");\n    }\n\n    /// @notice Registers implementations and performs an initialization call to a target address.\n    /// @dev This function handles the diamond cut, performs the initialization call, and emits a DiamondCut event.\n    /// @param _diamondCut An array of facet cuts to apply.\n    /// @param _initTarget The target address for the initialization call.\n    /// @param _initCalldata The calldata to execute on the initialization call.\n    function diamondCut(\n        Types.FacetCut[] calldata _diamondCut,\n        address _initTarget,\n        bytes calldata _initCalldata\n    ) external override onlyOwner {\n        LookupStorage._handleDiamondCut(_diamondCut);\n        LookupStorage._handleInitCall(_initTarget, _initCalldata);\n        emit DiamondCut(_diamondCut, _initTarget, _initCalldata);\n    }\n\n    /// @notice Retrieves the implementation address for a given function signature.\n    /// @dev Reverts if the implementation is locked to a specific contract.\n    /// @param _signature The function signature to look up.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature\n    ) external view override returns (address implementation) {\n        implementation = LookupStorage._signatureImplementation(_signature);\n        // Ensure implementation is not locked to specific\n        if (LookupStorage._getLockState(implementation)) {\n            revert InvalidLookupImplementation(implementation, _signature);\n        }\n    }\n\n    /// @notice Retrieves the implementation address for a given function signature and lock key.\n    /// @dev Reverts if the implementation is not locked to the specified key.\n    /// @param _signature The function signature to look up.\n    /// @param _lockKey The lock key to check against.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature,\n        bytes8 _lockKey\n    ) external view override returns (address implementation) {\n        implementation = LookupStorage._signatureImplementation(_signature);\n        // Ensure implementation is not locked to specific\n        if (!LookupStorage._getGlobalState(implementation)) {\n            if (LookupStorage._getLockKey(implementation) != _lockKey) {\n                revert InvalidLookupImplementation(implementation, _signature);\n            }\n        }\n    }\n\n    /// @notice Checks if the contract supports a given interface.\n    /// @param _interfaceId The interface ID to check.\n    /// @return bool True if the interface is supported, false otherwise.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool) {\n        return CommonStorage._getSupportedInterface(_interfaceId);\n    }\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev This function is called internally and updates the ownership in CommonStorage.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal override {\n        CommonStorage._setOwner(_newOwner);\n    }\n\n    /// @notice Gets the current contract owner.\n    /// @dev This function is called internally and retrieves the owner from CommonStorage.\n    /// @return The address of the current owner.\n    function _getOwner() internal view override returns (address) {\n        return CommonStorage._getOwner();\n    }\n}\n"
      },
      "project/contracts/interface/IDiamondCut.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {Types} from \"../libs/Types.sol\";\n\n/// @title IDiamondCut\n/// @author AdeThorMiwa\n/// @notice Interface for the DiamondCut operation.\n/// @dev Defines the functions for adding, replacing, or removing facets in a diamond contract.\ninterface IDiamondCut {\n    /// @dev Emitted when a diamond cut operation is executed.\n    /// @param _diamondCut An array of facet cut actions.\n    /// @param _init The address of the initialization contract (if any).\n    /// @param _calldata The calldata for the initialization call (if any).\n    event DiamondCut(\n        Types.FacetCut[] _diamondCut,\n        address indexed _init,\n        bytes _calldata\n    );\n\n    /// @dev Adds, replaces, or removes facets in a diamond contract.\n    /// @param _diamondCut An array of facet cut actions.\n    function diamondCut(Types.FacetCut[] calldata _diamondCut) external;\n\n    /// @dev Adds, replaces, or removes facets in a diamond contract and executes an initialization call.\n    /// @param _diamondCut An array of facet cut actions.\n    /// @param _initTarget The address of the initialization contract.\n    /// @param _initCalldata The calldata for the initialization call.\n    function diamondCut(\n        Types.FacetCut[] calldata _diamondCut,\n        address _initTarget,\n        bytes calldata _initCalldata\n    ) external;\n}\n"
      },
      "project/contracts/interface/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC165\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC165 standard.\n/// @dev This interface allows contracts to declare and query support for specific interfaces.\ninterface IERC165 {\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// @param interfaceId The interface identifier, as specified in ERC-165.\n    /// @return True if the contract implements the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/interface/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC173: Contract Ownership\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC-173 Contract Ownership Standard.\n/// @dev See https://eips.ethereum.org/EIPS/eip-173 for more details.\ninterface IERC173 {\n    /// @dev Emitted when ownership of the contract is transferred.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev Setting `newOwner` to the zero address renounces ownership.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external;\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return owner The address of the contract owner.\n    function owner() external view returns (address);\n}\n"
      },
      "project/contracts/interface/ILookup.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC173} from \"./IERC173.sol\";\n\n/// @title ILookup\n/// @author AdeThorMiwa\n/// @notice Interface for managing implementation lookup.\n/// @dev Provides functions for retrieving and managing implementations based on function signatures.\ninterface ILookup is IERC165, IERC173 {\n    /// @dev Locks an implementation with a specific lock key.\n    /// @param _implementation The address of the implementation.\n    /// @param _lockKey The lock key for the implementation.\n    function lockImplementation(\n        address _implementation,\n        bytes8 _lockKey\n    ) external;\n\n    /// @dev Sets the global usage flag for an implementation.\n    /// @param _implementation The address of the implementation.\n    /// @param _allowGlobal Whether the implementation can be used globally.\n    function setGlobalUse(address _implementation, bool _allowGlobal) external;\n\n    /// @dev Returns the implementation address for a given function signature.\n    /// @param _signature The function signature.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature\n    ) external view returns (address implementation);\n\n    /// @dev Returns the implementation address for a given function signature and lock key.\n    /// @param _signature The function signature.\n    /// @param _lockKey The lock key for the implementation.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature,\n        bytes8 _lockKey\n    ) external view returns (address implementation);\n}\n"
      },
      "project/contracts/libs/CheckAddress.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckAddress Library\n/// @author AdeThorMiwa\n/// @notice Provides utility functions for address type, particularly to check if an address is a contract.\n/// @dev This library contains a function to determine if an address has associated contract code.\nlibrary CheckAddress {\n    /// @dev Checks if an address has associated contract code.\n    /// @param _address The address to check for contract code.\n    /// @return bool indicating whether the address has contract code.\n    function hasContractCode(address _address) internal view returns (bool) {\n        uint256 _codeSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _codeSize := extcodesize(_address)\n        }\n        return _codeSize > 0;\n    }\n}\n"
      },
      "project/contracts/libs/CommonStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {InvalidInputData, ZeroAddressNotAllowed, UnauthorizedAccount} from \"../utils/Errors.sol\";\n\n/// @title CommonStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing common storage data.\n/// @dev This library contains functions for setting and getting various contract addresses,\n///      enforcing ownership, and managing supported interfaces.\nlibrary CommonStorage {\n    /// @dev Structure representing common storage used in the contract.\n    struct CStorage {\n        // The address of the owner, which is payable.\n        address payable owner;\n        // The address of the lookup proxy.\n        address lookupProxy;\n        // The address of the factory.\n        address factory;\n        // A mapping to track supported interfaces, using function selectors as keys and boolean values.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant COMMON_STORAGE_SLOT =\n        keccak256(\"com.stash.common.storage\");\n\n    /// @dev This emits when ownership of a contract changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Lookup proxy change event.\n    /// @param previousProxy The address of the previous proxy.\n    /// @param newProxy The address of the new proxy.\n    event LookupProxyChanged(\n        address indexed previousProxy,\n        address indexed newProxy\n    );\n\n    /// @dev Sets the factory address.\n    /// @param _factory The new factory address.\n    function _setFactory(address _factory) internal {\n        if (_factory == address(0))\n            revert ZeroAddressNotAllowed(\"PROTOCOL_FACTORY\");\n\n        CStorage storage cs = cStore();\n        cs.factory = _factory;\n    }\n\n    /// @dev Sets the contract owner.\n    /// @param _owner The new owner address.\n    function _setOwner(address _owner) internal {\n        if (_owner == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n\n        address previousOwner = _getOwner();\n        CStorage storage cs = cStore();\n        cs.owner = payable(_owner);\n        emit OwnershipTransferred(previousOwner, _owner);\n    }\n\n    /// @dev Sets the current stash lookup contract.\n    /// @param _lookupProxy The new stash lookup contract address.\n    function _setLookupProxy(address _lookupProxy) internal {\n        if (_lookupProxy == address(0))\n            revert ZeroAddressNotAllowed(\"LOOKUP_PROXY\");\n\n        address previousProxy = _getLookupProxy();\n        CStorage storage cs = cStore();\n        cs.lookupProxy = _lookupProxy;\n        emit LookupProxyChanged(previousProxy, _lookupProxy);\n    }\n\n    /// @dev Sets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @param _supported True if the interface is supported, false otherwise.\n    function _setSupportedInterface(\n        bytes4 _interfaceId,\n        bool _supported\n    ) internal {\n        if (_interfaceId == bytes4(0))\n            revert InvalidInputData(\"_interfaceId\", \"INVALID_LENGTH\");\n\n        CStorage storage cs = cStore();\n        cs.supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    /// @dev Gets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @return supported True if the interface is supported, false otherwise.\n    function _getSupportedInterface(\n        bytes4 _interfaceId\n    ) internal view returns (bool supported) {\n        supported = cStore().supportedInterfaces[_interfaceId];\n    }\n\n    /// @dev Gets the current stash lookup contract.\n    /// @return lookupProxy The current stash lookup address.\n    function _getLookupProxy() internal view returns (address lookupProxy) {\n        lookupProxy = cStore().lookupProxy;\n    }\n\n    /// @dev Ensures the message sender is the current contract owner.\n    function enforceIsOwner() internal view {\n        if (msg.sender != _getOwner())\n            revert UnauthorizedAccount(msg.sender, \"NOT_OWNER\");\n    }\n\n    /// @dev Gets contract owner.\n    /// @return owner The address of the owner.\n    function _getOwner() internal view returns (address owner) {\n        owner = cStore().owner;\n    }\n\n    /// @dev Gets the factory contract Address.\n    /// @return factory The address of the factory contract.\n    function _getFactory() internal view returns (address factory) {\n        factory = cStore().factory;\n    }\n\n    /// @dev Retrieves the storage structure.\n    /// @return sc The storage structure.\n    function cStore() internal pure returns (CStorage storage sc) {\n        bytes32 pos = COMMON_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sc.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/LookupStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {Types} from \"../libs/Types.sol\";\nimport {CheckAddress} from \"../libs/CheckAddress.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {ImmutableImplementationReplacementError, NotContractAddress, EmptyInitCallData} from \"../utils/Errors.sol\";\nimport {FacetSelectorExists, InvalidFacetFunction, InvalidFuncSelectorsCount} from \"../utils/Errors.sol\";\nimport {InvalidFacetContract, ImmutableFunctionReplacementError} from \"../utils/Errors.sol\";\n\n/// @title LookupStorage Library\n/// @author AdeThorMiwa\n/// @notice Library for managing storage and function selectors for a diamond facet implementation.\n/// @dev This library includes functionality for handling diamond cuts, retrieving and setting lock states,\n///      and managing function selectors and implementations.\nlibrary LookupStorage {\n    using Address for address;\n    using CheckAddress for address;\n\n    /// @dev Implementation address and selector position\n    struct ImpleAddrAndSelectorPos {\n        // Address of the facet\n        address facetAddress;\n        // Position of the selector in the selectors array\n        uint16 selectorPosition;\n    }\n\n    /// @dev Structure representing the lookup storage used in the contract\n    struct LStorage {\n        // Array of function selectors\n        bytes4[] selectors;\n        // Mapping to track lock state of implementations\n        mapping(address => bool) lockState;\n        // Mapping to track global implementation state\n        mapping(address => bool) globalImplementation;\n        // Mapping to track implementation lock keys\n        mapping(address => bytes8) implementationLock;\n        // Mapping to track implementation address and selector position\n        mapping(bytes4 => ImpleAddrAndSelectorPos) impleAddrAndSelectorPos;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant LOOKUP_STORAGE_SLOT =\n        keccak256(\"com.stash.lookup.storage\");\n\n    /// @notice Add/Replace functions\n    /// @dev Gas estimate values in function are conservative value not absolute values\n    /// @param _diamondCut Array of diamond facet cut operations\n    function _handleDiamondCut(Types.FacetCut[] memory _diamondCut) internal {\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            Types.FacetCut memory facetCut = _diamondCut[i];\n\n            address _facetAddress = _diamondCut[i].facetAddress;\n\n            bytes4[] memory _functionSelectors = _diamondCut[i]\n                .functionSelector;\n\n            if (!_facetAddress.hasContractCode())\n                revert InvalidFacetContract(_facetAddress);\n\n            if (_functionSelectors.length == 0)\n                revert InvalidFuncSelectorsCount(_functionSelectors.length);\n\n            if (facetCut.action == Types.FacetCutAction.ADD) {\n                _addFunctions(_facetAddress, _functionSelectors);\n            } else if (facetCut.action == Types.FacetCutAction.REPLACE) {\n                _replaceFunctions(_facetAddress, _functionSelectors);\n            } else if (facetCut.action == Types.FacetCutAction.REMOVE) {\n                _removeFunctions(_functionSelectors);\n            }\n        }\n    }\n\n    /// @dev Enable or disable implementation lock state\n    /// @param _implementation Address of the implementation\n    /// @param _lockState New lock state to be set\n    function _setLockState(address _implementation, bool _lockState) internal {\n        _store().lockState[_implementation] = _lockState;\n    }\n\n    /// @dev Handle DiamondCut Add functions operations\n    /// @param _facetAddress Facet address\n    /// @param _functionSelectors Array of function selector signatures to add\n    function _addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        LStorage storage ls = _store();\n\n        uint16 _selectorsCount = uint16(ls.selectors.length);\n\n        for (uint256 i = 0; i < _functionSelectors.length; i++) {\n            /// @dev indexSelector\n            bytes4 _selector = _functionSelectors[i];\n            /// @dev existng facet implementation at selector psosition\n            address _oldImplementation = ls\n                .impleAddrAndSelectorPos[_selector]\n                .facetAddress;\n\n            /// @dev Avoid implementation override\n            if (_oldImplementation.hasContractCode())\n                revert FacetSelectorExists(_oldImplementation, _selector);\n\n            /// @dev Add function\n            ls.impleAddrAndSelectorPos[_selector] = ImpleAddrAndSelectorPos(\n                _facetAddress,\n                _selectorsCount\n            );\n\n            ls.selectors.push();\n            ls.selectors[_selectorsCount] = _selector;\n            _selectorsCount++;\n        }\n    }\n\n    /// @dev Handle DiamondCut Replace functions\n    /// @param _facetAddress Facet address\n    /// @param _functionSelectors Array of function selector signatures to replace\n    function _replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        LStorage storage ls = _store();\n\n        for (uint256 i = 0; i < _functionSelectors.length; i++) {\n            bytes4 _selector = _functionSelectors[i];\n            address _oldImplementation = ls\n                .impleAddrAndSelectorPos[_selector]\n                .facetAddress;\n\n            if (_oldImplementation == address(this))\n                revert ImmutableFunctionReplacementError(\n                    _oldImplementation,\n                    _selector\n                );\n\n            if (_oldImplementation == _facetAddress)\n                revert ImmutableImplementationReplacementError(\n                    _oldImplementation,\n                    _selector\n                );\n\n            if (_oldImplementation == address(0))\n                revert InvalidFacetContract(_oldImplementation);\n\n            ls.impleAddrAndSelectorPos[_selector].facetAddress = _facetAddress;\n        }\n    }\n\n    /// @dev Handle DiamondCut Remove functions\n    /// @param _functionSelectors Array of  function selector signatures to replace\n    function _removeFunctions(bytes4[] memory _functionSelectors) internal {\n        LStorage storage ls = _store();\n\n        uint256 curSelectorsCount = ls.selectors.length;\n\n        for (uint256 i = 0; i < _functionSelectors.length; i++) {\n            bytes4 selector = _functionSelectors[i];\n\n            ImpleAddrAndSelectorPos memory oldAddressAndPos = ls\n                .impleAddrAndSelectorPos[selector];\n\n            if (oldAddressAndPos.facetAddress == address(0))\n                revert InvalidFacetFunction(\n                    oldAddressAndPos.facetAddress,\n                    selector\n                );\n\n            if (oldAddressAndPos.facetAddress == address(this))\n                revert ImmutableImplementationReplacementError(\n                    oldAddressAndPos.facetAddress,\n                    selector\n                );\n\n            curSelectorsCount--;\n\n            if (oldAddressAndPos.selectorPosition != curSelectorsCount) {\n                bytes4 lastSelector = ls.selectors[curSelectorsCount];\n                ls.selectors[oldAddressAndPos.selectorPosition] = lastSelector;\n                ls\n                    .impleAddrAndSelectorPos[lastSelector]\n                    .selectorPosition = oldAddressAndPos.selectorPosition;\n            }\n\n            ls.selectors.pop();\n\n            delete ls.impleAddrAndSelectorPos[selector];\n        }\n    }\n\n    /// @dev Handle post-facet registration calls\n    /// @param _targetAddress Address of the target contract\n    /// @param _initCallData Initialization call data\n    function _handleInitCall(\n        address _targetAddress,\n        bytes memory _initCallData\n    ) internal {\n        if (_targetAddress != address(this)) {\n            if (!_targetAddress.hasContractCode())\n                revert NotContractAddress(_targetAddress);\n        }\n\n        if (_initCallData.length == 0) revert EmptyInitCallData();\n\n        _targetAddress.functionDelegateCall(_initCallData);\n    }\n\n    /// @dev Set implementation lock key\n    /// @param _implementation Address of the implementation\n    /// @param _lockKey New lock key to be set\n    function _setLockKey(address _implementation, bytes8 _lockKey) internal {\n        _store().implementationLock[_implementation] = _lockKey;\n    }\n\n    /// @dev Enable or disable global implementation state\n    /// @param _implementation Address of the implementation\n    /// @param _gState New global state to be set\n    function _setGlobalState(address _implementation, bool _gState) internal {\n        _store().globalImplementation[_implementation] = _gState;\n    }\n\n    /// @dev Get implementation address using call signature\n    /// @param _signature Call signature\n    /// @return implementation Call signature facet implementation\n    function _signatureImplementation(\n        bytes4 _signature\n    ) internal view returns (address implementation) {\n        LookupStorage.LStorage storage ls = _store();\n        implementation = address(\n            bytes20(ls.impleAddrAndSelectorPos[_signature].facetAddress)\n        );\n    }\n\n    /// @dev Get implementation lock state\n    /// @param _implementation Address of the implementation\n    /// @return lockState Lock state of the implementation\n    function _getLockState(\n        address _implementation\n    ) internal view returns (bool lockState) {\n        lockState = _store().lockState[_implementation];\n    }\n\n    /// @dev Get implementation lock key\n    /// @param _implementation Address of the implementation\n    /// @return lockKey Lock key of the implementation\n    function _getLockKey(\n        address _implementation\n    ) internal view returns (bytes8 lockKey) {\n        lockKey = _store().implementationLock[_implementation];\n    }\n\n    /// @dev Is implementation global\n    /// @param _implementation Address of the implementation\n    /// @return gImplState Global implementation state\n    function _getGlobalState(\n        address _implementation\n    ) internal view returns (bool gImplState) {\n        gImplState = _store().globalImplementation[_implementation];\n    }\n\n    /// @dev Get object from storage slot\n    /// @return ls Lookup Storage object\n    function _store() internal pure returns (LStorage storage ls) {\n        bytes32 pos = LOOKUP_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ls.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/Types.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Types Library\n/// @author AdeThorMiwa\n/// @notice Library to hold re-usable custom types\n/// @dev Declare re-usable enums and structs\nlibrary Types {\n    /// @dev Enum to represent the type of action to be taken on a facet cut.\n    enum FacetCutAction {\n        ADD, // 0: Add a new facet.\n        REPLACE, // 1: Replace an existing facet.\n        REMOVE // 2: Remove a facet.\n    }\n\n    /// @dev Struct to represent a cut on a facet.\n    struct FacetCut {\n        //The address of the facet.\n        address facetAddress;\n        // The action to be taken on the facet.\n        FacetCutAction action;\n        // The list of function selectors for the facet.\n        bytes4[] functionSelector;\n    }\n\n    /// @dev Struct to represent client arguments.\n    struct ClientArgs {\n        // The address of the client.\n        address client;\n    }\n\n    enum StashStatus {\n        OPEN,\n        CLOSED\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}