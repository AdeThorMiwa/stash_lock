{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-852f16253f53b40abea5b3c67041250a48cb5b5e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/implementation/FactoryOps.sol": "project/contracts/implementation/FactoryOps.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/common/Context.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Context\n/// @author AdeThorMiwa\n/// @notice This contract is an abstract base contract that provides\n///         commonly used functions for accessing message information from the current context.\n/// @dev It is intended to be inherited by other contracts that need access to\n///      `msg.sender`, `msg.data`, `msg.sig`, and `msg.value`.\nabstract contract Context {\n    /// @dev Returns the message sender address from the current context.\n    /// @return msgSender The address of the message sender.\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    /// @dev Returns the message value (in wei) of the current context.\n    /// @return msgValue The value of the message in wei.\n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}\n"
      },
      "project/contracts/common/Ownable.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {IERC173} from \"../interface/IERC173.sol\";\n\nimport {UnauthorizedAccount, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\nimport {Context} from \"./Context.sol\";\n\n/// @title Ownable\n/// @author AdeThorMiwa\n/// @notice This contract implements the Ownable standard, allowing for the\n///         management of a contract's owner.\n/// @dev This implementation is based on the EIP-173 standard: https://eips.ethereum.org/EIPS/eip-173\nabstract contract Ownable is Context, IERC173 {\n    /// @dev The address of the current contract owner.\n    address private _owner;\n\n    /// @dev A modifier that restricts function execution to the contract owner.\n    modifier onlyOwner() {\n        if (_msgSender() != _getOwner())\n            revert UnauthorizedAccount(_msgSender(), \"NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new account (`_newOwner`).\n    /// @dev This function can only be called by the current contract owner.\n    ///         Reverts if the new owner is the zero address.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        if (_newOwner == address(0)) revert ZeroAddressNotAllowed(\"NEW_OWNER\");\n        _transferOwnership(_newOwner);\n    }\n\n    /// @notice Renounces ownership of the contract by transferring it to the zero address.\n    /// @dev This function can only be called by the current contract owner.\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return address The address of the current owner.\n    function owner() external view override returns (address) {\n        return _getOwner();\n    }\n\n    /// @notice Transfers ownership of the contract to a new account Â (`_newOwner`).\n    /// @dev This is an internal function, not meant to be called directly.\n    ///      Emits an `OwnershipTransferred` event after ownership is transferred.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal virtual {\n        address _previousOwner = _getOwner();\n        _owner = _newOwner;\n        emit OwnershipTransferred(_previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the address of the current contract owner.\n    /// @dev This is an internal function, not meant to be called directly.\n    /// @return address The address of the current owner.\n    function _getOwner() internal view virtual returns (address) {\n        return _owner;\n    }\n}\n"
      },
      "project/contracts/common/UseLookup.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {CheckAddress} from \"../libs/CheckAddress.sol\";\n\nimport {InvalidLookupImplementation} from \"../utils/Errors.sol\";\n\n/// @title UseLookup\n/// @author AdeThorMiwa\n/// @notice Abstract base contract for lookup-based function delegation.\n/// @dev This contract enables delegating function calls to dynamically deployed\n///      implementation contracts based on function signatures. It acts as a\n///      lookup proxy and utilizes a separate contract {LookupOps}\n///      to manage the mapping between function signatures and implementation\n///\nabstract contract UseLookup {\n    using CheckAddress for address;\n\n    /// @dev Event emitted when a deposit is received to the contract.\n    /// @param stash The address of the related stash contract (if applicable).\n    /// @param from The address of the sender.\n    /// @param value The amount of the deposit.\n    event DepositReceived(\n        address indexed stash,\n        address indexed from,\n        uint256 value\n    );\n\n    /// @notice Function to receive ether sent directly to the contract.\n    /// @dev Emits a `DepositReceived` event for tracking.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable virtual {\n        emit DepositReceived(address(this), msg.sender, msg.value);\n    }\n\n    /// @notice Fallback function to handle calls to non-existent functions.\n    /// @dev This function delegates the call to the appropriate implementation contract\n    ///      based on the function signature using the `_delegate` function.\n    fallback() external payable virtual {\n        _delegate();\n    }\n\n    /// @dev Internal function to delegate a function call based on the message signature.\n    function _delegate() internal {\n        address implementation = _implementation(msg.sig);\n\n        if (!implementation.hasContractCode()) {\n            revert InvalidLookupImplementation(implementation, msg.sig);\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            // check returned result\n            switch result\n            // delegate call returns 0 on error\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @notice Abstract function to retrieve the implementation address for a function signature.\n    /// @dev This function should be implemented in the inheriting contract to define the\n    ///      logic for retrieving the implementation address based on the function signature.\n    ///      It should return the address of the implementation contract or the zero address\n    ///      if no implementation is found.\n    /// @param _signature The function signature (4 bytes).\n    /// @return implementation The address of the implementation contract.\n    function _implementation(\n        bytes4 _signature\n    ) internal view virtual returns (address implementation);\n}\n"
      },
      "project/contracts/implementation/FactoryOps.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IFactory} from \"../interface/IFactory.sol\";\n\nimport {CommonStorage} from \"../libs/CommonStorage.sol\";\nimport {FactoryStorage} from \"../libs/FactoryStorage.sol\";\nimport {StashLimitReached, ZeroAddressNotAllowed, ActionRejected} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../common/Ownable.sol\";\nimport {Stash} from \"../Stash.sol\";\n\n/// @title FactoryOps Contract\n/// @author AdeThorMiwa\n/// @notice This contract handles operations for managing stashs within a factory.\n/// @dev Handles stash contract creation and registration\ncontract FactoryOps is Ownable, IFactory {\n    /// @notice Creates a new stash for the message sender.\n    function createStash() external override {\n        _createStash(_msgSender());\n    }\n\n    /// @dev Creates a new stash for a specific owner.\n    /// @param _ownerAddress The address of the owner.\n    /// @dev Only the owner can call this function.\n    function createStash(address _ownerAddress) external override onlyOwner {\n        if (_ownerAddress == address(0))\n            revert ZeroAddressNotAllowed(\"TP_ADDRESS\");\n        _createStash(_ownerAddress);\n    }\n\n    /// @dev Checks if a given address is a stash.\n    /// @param _stash The address to check.\n    /// @return True if the address is a stash, false otherwise.\n    function isStash(address _stash) external view returns (bool) {\n        return FactoryStorage._isStash(_stash);\n    }\n\n    /// @notice Checks if the contract supports a specific interface.\n    /// @param _interfaceId The interface identifier to check.\n    /// @return bool True if the interface is supported, false otherwise.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool) {\n        return CommonStorage._getSupportedInterface(_interfaceId);\n    }\n\n    /// @notice Gets the current lookup proxy address for the factory.\n    /// @return address The address of the current lookup proxy.\n    function getLookupProxy() external view override returns (address) {\n        return CommonStorage._getLookupProxy();\n    }\n\n    /// @dev Returns an array of stash owned by a given address.\n    /// @param _ownerAddress The address of the stash owner.\n    /// @return stashes An array of stash addresses.\n    /// @return currentCount The number of stash owned by the address.\n    function getStashes(\n        address _ownerAddress\n    ) external view returns (address[] memory stashes, uint256 currentCount) {\n        return FactoryStorage._getStashes(_ownerAddress);\n    }\n\n    /// @dev Internal function to create a stash using CREATE2.\n    /// @param _ownerAddress The third-party address to create the stash account for.\n    function _createStash(address _ownerAddress) internal {\n        address stash;\n        uint256 stashIndex;\n\n        address lookupProxy = CommonStorage._getLookupProxy();\n\n        uint16 maxStash = FactoryStorage._getUserStashLimit();\n\n        (, stashIndex) = FactoryStorage._getStashes(_ownerAddress);\n\n        // Check account serial limit\n        if (stashIndex >= maxStash) {\n            revert StashLimitReached(_ownerAddress, maxStash);\n        }\n\n        // Hash tp address and serial to get unique salt\n        bytes32 salt = keccak256(abi.encodePacked(_ownerAddress, stashIndex));\n\n        // This will generate a Stash Contract using CREATE2\n        // solhint-disable-next-line no-inline-assembly\n        bytes memory _bytecode = abi.encodePacked(\n            type(Stash).creationCode,\n            abi.encode(_ownerAddress, address(this), lookupProxy)\n        );\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            stash := create2(0, add(_bytecode, 32), mload(_bytecode), salt)\n        }\n\n        // Add Savings Account\n        FactoryStorage._addStash(_ownerAddress, stash, stashIndex);\n\n        emit StashCreated(_ownerAddress, stash, stashIndex);\n    }\n\n    /// @dev Overrides the ownership transfer implementation to use the implemented storage.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal override {\n        CommonStorage._setOwner(_newOwner);\n    }\n\n    /// @dev Overrides the get owner implementation to use the implemented storage.\n    /// @return address The address of the current owner.\n    function _getOwner() internal view override returns (address) {\n        return CommonStorage._getOwner();\n    }\n}\n"
      },
      "project/contracts/interface/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC165\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC165 standard.\n/// @dev This interface allows contracts to declare and query support for specific interfaces.\ninterface IERC165 {\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// @param interfaceId The interface identifier, as specified in ERC-165.\n    /// @return True if the contract implements the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/interface/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC173: Contract Ownership\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC-173 Contract Ownership Standard.\n/// @dev See https://eips.ethereum.org/EIPS/eip-173 for more details.\ninterface IERC173 {\n    /// @dev Emitted when ownership of the contract is transferred.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev Setting `newOwner` to the zero address renounces ownership.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external;\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return owner The address of the contract owner.\n    function owner() external view returns (address);\n}\n"
      },
      "project/contracts/interface/IFactory.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC173} from \"./IERC173.sol\";\n\n/// @title IFactory\n/// @author AdeThorMiwa\n/// @notice Interface for managing stash.\n/// @dev Provides functions for creating, managing, and querying stash.\ninterface IFactory is IERC173, IERC165 {\n    /// @dev Emitted when a new stash is created.\n    /// @param owner The address of the stash owner.\n    /// @param stash The address of the newly created stash.\n    /// @param index The index of the stash within the owner's stashes.\n    event StashCreated(\n        address indexed owner,\n        address indexed stash,\n        uint256 indexed index\n    );\n\n    /// @dev Emitted when stash this deployed to a location.\n    /// @param owner The address of the stash owner.\n    /// @param stash The address of the newly created stash.\n    /// @param index The index of the stash within the owner's stashes.\n    event StashDeployed(\n        address indexed owner,\n        address indexed stash,\n        uint256 indexed index\n    );\n\n    /// @dev Creates a new stash for the message sender.\n    function createStash() external;\n\n    /// @dev Creates a new stash for a specific owner.\n    /// @param _ownerAddress The address of the owner.\n    function createStash(address _ownerAddress) external;\n\n    /// @dev Checks if a given address is a stash.\n    /// @param _stash The address to check.\n    /// @return True if the address is a stash, false otherwise.\n    function isStash(address _stash) external view returns (bool);\n\n    /// @dev Returns the address of the lookup proxy contract.\n    /// @return The address of the lookup proxy contract.\n    function getLookupProxy() external view returns (address);\n\n    /// @dev Returns an array of stash owned by a given address.\n    /// @param _ownerAddress The address of the stash owner.\n    /// @return stashes An array of stash addresses.\n    /// @return currentCount The number of stash owned by the address.\n    function getStashes(\n        address _ownerAddress\n    ) external view returns (address[] memory stashes, uint256 currentCount);\n}\n"
      },
      "project/contracts/interface/ILookup.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC173} from \"./IERC173.sol\";\n\n/// @title ILookup\n/// @author AdeThorMiwa\n/// @notice Interface for managing implementation lookup.\n/// @dev Provides functions for retrieving and managing implementations based on function signatures.\ninterface ILookup is IERC165, IERC173 {\n    /// @dev Locks an implementation with a specific lock key.\n    /// @param _implementation The address of the implementation.\n    /// @param _lockKey The lock key for the implementation.\n    function lockImplementation(\n        address _implementation,\n        bytes8 _lockKey\n    ) external;\n\n    /// @dev Sets the global usage flag for an implementation.\n    /// @param _implementation The address of the implementation.\n    /// @param _allowGlobal Whether the implementation can be used globally.\n    function setGlobalUse(address _implementation, bool _allowGlobal) external;\n\n    /// @dev Returns the implementation address for a given function signature.\n    /// @param _signature The function signature.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature\n    ) external view returns (address implementation);\n\n    /// @dev Returns the implementation address for a given function signature and lock key.\n    /// @param _signature The function signature.\n    /// @param _lockKey The lock key for the implementation.\n    /// @return implementation The address of the implementation.\n    function getImplementation(\n        bytes4 _signature,\n        bytes8 _lockKey\n    ) external view returns (address implementation);\n}\n"
      },
      "project/contracts/libs/CheckAddress.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckAddress Library\n/// @author AdeThorMiwa\n/// @notice Provides utility functions for address type, particularly to check if an address is a contract.\n/// @dev This library contains a function to determine if an address has associated contract code.\nlibrary CheckAddress {\n    /// @dev Checks if an address has associated contract code.\n    /// @param _address The address to check for contract code.\n    /// @return bool indicating whether the address has contract code.\n    function hasContractCode(address _address) internal view returns (bool) {\n        uint256 _codeSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _codeSize := extcodesize(_address)\n        }\n        return _codeSize > 0;\n    }\n}\n"
      },
      "project/contracts/libs/CommonStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {InvalidInputData, ZeroAddressNotAllowed, UnauthorizedAccount} from \"../utils/Errors.sol\";\n\n/// @title CommonStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing common storage data.\n/// @dev This library contains functions for setting and getting various contract addresses,\n///      enforcing ownership, and managing supported interfaces.\nlibrary CommonStorage {\n    /// @dev Structure representing common storage used in the contract.\n    struct CStorage {\n        // The address of the owner, which is payable.\n        address payable owner;\n        // The address of the lookup proxy.\n        address lookupProxy;\n        // The address of the factory.\n        address factory;\n        // A mapping to track supported interfaces, using function selectors as keys and boolean values.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    /// @dev Random storage slot\n    bytes32 internal constant COMMON_STORAGE_SLOT =\n        keccak256(\"com.stash.common.storage\");\n\n    /// @dev This emits when ownership of a contract changes.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Lookup proxy change event.\n    /// @param previousProxy The address of the previous proxy.\n    /// @param newProxy The address of the new proxy.\n    event LookupProxyChanged(\n        address indexed previousProxy,\n        address indexed newProxy\n    );\n\n    /// @dev Sets the factory address.\n    /// @param _factory The new factory address.\n    function _setFactory(address _factory) internal {\n        if (_factory == address(0))\n            revert ZeroAddressNotAllowed(\"PROTOCOL_FACTORY\");\n\n        CStorage storage cs = cStore();\n        cs.factory = _factory;\n    }\n\n    /// @dev Sets the contract owner.\n    /// @param _owner The new owner address.\n    function _setOwner(address _owner) internal {\n        if (_owner == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n\n        address previousOwner = _getOwner();\n        CStorage storage cs = cStore();\n        cs.owner = payable(_owner);\n        emit OwnershipTransferred(previousOwner, _owner);\n    }\n\n    /// @dev Sets the current stash lookup contract.\n    /// @param _lookupProxy The new stash lookup contract address.\n    function _setLookupProxy(address _lookupProxy) internal {\n        if (_lookupProxy == address(0))\n            revert ZeroAddressNotAllowed(\"LOOKUP_PROXY\");\n\n        address previousProxy = _getLookupProxy();\n        CStorage storage cs = cStore();\n        cs.lookupProxy = _lookupProxy;\n        emit LookupProxyChanged(previousProxy, _lookupProxy);\n    }\n\n    /// @dev Sets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @param _supported True if the interface is supported, false otherwise.\n    function _setSupportedInterface(\n        bytes4 _interfaceId,\n        bool _supported\n    ) internal {\n        if (_interfaceId == bytes4(0))\n            revert InvalidInputData(\"_interfaceId\", \"INVALID_LENGTH\");\n\n        CStorage storage cs = cStore();\n        cs.supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    /// @dev Gets whether a specific interface is supported.\n    /// @param _interfaceId The interface ID.\n    /// @return supported True if the interface is supported, false otherwise.\n    function _getSupportedInterface(\n        bytes4 _interfaceId\n    ) internal view returns (bool supported) {\n        supported = cStore().supportedInterfaces[_interfaceId];\n    }\n\n    /// @dev Gets the current stash lookup contract.\n    /// @return lookupProxy The current stash lookup address.\n    function _getLookupProxy() internal view returns (address lookupProxy) {\n        lookupProxy = cStore().lookupProxy;\n    }\n\n    /// @dev Ensures the message sender is the current contract owner.\n    function enforceIsOwner() internal view {\n        if (msg.sender != _getOwner())\n            revert UnauthorizedAccount(msg.sender, \"NOT_OWNER\");\n    }\n\n    /// @dev Gets contract owner.\n    /// @return owner The address of the owner.\n    function _getOwner() internal view returns (address owner) {\n        owner = cStore().owner;\n    }\n\n    /// @dev Gets the factory contract Address.\n    /// @return factory The address of the factory contract.\n    function _getFactory() internal view returns (address factory) {\n        factory = cStore().factory;\n    }\n\n    /// @dev Retrieves the storage structure.\n    /// @return sc The storage structure.\n    function cStore() internal pure returns (CStorage storage sc) {\n        bytes32 pos = COMMON_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sc.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/libs/FactoryStorage.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title FactoryStorage Library\n/// @author AdeThorMiwa\n/// @notice Provides a storage structure and utility functions for managing factory-related storage data.\n/// @dev This library contains functions for managing stash and user account limits.\nlibrary FactoryStorage {\n    /// @dev Factory storage structure.\n    struct FStorage {\n        // The maximum number of stash allowed to be created by a single user.\n        uint16 userMaxStash;\n        // Mapping indicating whether an address is a stash.\n        mapping(address => bool) isStash;\n        // Mapping of user addresses to their stashes.\n        mapping(address => address[]) stashes;\n    }\n\n    /// @dev Random storage slot for factory storage.\n    bytes32 internal constant FACTORY_STORAGE_SLOT =\n        keccak256(\"com.stash.factory.storage\");\n\n    /// @dev Sets the allowed maximum number of user stash.\n    /// @param _limit The maximum user stash limit.\n    function _setUserMaxStash(uint16 _limit) internal {\n        FStorage storage fs = _store();\n        fs.userMaxStash = _limit;\n    }\n\n    /// @dev Adds a stash for an owner.\n    /// @param _owner The owner's address.\n    /// @param _stashAddress The stash address.\n    /// @param _stashIndex The index of the stash.\n    function _addStash(\n        address _owner,\n        address _stashAddress,\n        uint256 _stashIndex\n    ) internal {\n        FStorage storage fs = _store();\n        fs.stashes[_owner].push();\n        fs.stashes[_owner][_stashIndex] = _stashAddress;\n        fs.isStash[_stashAddress] = true;\n    }\n\n    /// @dev Checks if an address is a registered stash.\n    /// @param _stash The address to check.\n    /// @return True if the address is a registered stash, false otherwise.\n    function _isStash(address _stash) internal view returns (bool) {\n        return _store().isStash[_stash];\n    }\n\n    /// @dev Gets the allowed maximum number of user stash.\n    /// @return maxStash The allowed maximum number of user stash.\n    function _getUserStashLimit() internal view returns (uint16 maxStash) {\n        maxStash = _store().userMaxStash;\n    }\n\n    /// @dev Gets the stash associated with a owner.\n    /// @param _ownerAddress The owner's address.\n    /// @return stashes The list of stash accounts.\n    /// @return currentCount The current number of stash accounts.\n    function _getStashes(\n        address _ownerAddress\n    ) internal view returns (address[] memory stashes, uint256 currentCount) {\n        stashes = _store().stashes[_ownerAddress];\n        currentCount = stashes.length;\n    }\n\n    /// @dev Returns storage value from designated slot.\n    /// @return fs The factory storage structure.\n    function _store() internal pure returns (FStorage storage fs) {\n        bytes32 pos = FACTORY_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            fs.slot := pos\n        }\n    }\n}\n"
      },
      "project/contracts/Stash.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {ILookup, IERC165, IERC173} from \"./interface/ILookup.sol\";\n\nimport {CommonStorage} from \"./libs/CommonStorage.sol\";\n\nimport {UseLookup} from \"./common/UseLookup.sol\";\n\n/// @title Stash Contract\n/// @author AdeThorMiwa\n/// @notice This contract handles the stash account functionality including setup and lookup implementations.\n/// @dev The contract is created using CREATE2 to ensure consistent stash addresses across EVM chains.\ncontract Stash is UseLookup {\n    /// @notice This key is used to lock implementations to Stash contract\n    /// @dev This is calculated thus: bytes8(keccak256(abi.encodePacked(\"Stash\")))\n    bytes8 public constant IMPL_KEY = 0x1a76ecadaefb8d4f;\n\n    /// @notice constructs stash contract\n    /// @dev contract is created using CREATE2 to ensure some sort of stash address consistently across evm chains for owner\n    /// @param factory stash factory address\n    /// @param owner stash contract owner address\n    /// @param lookupProxy implementation lookup proxy address\n    constructor(address owner, address factory, address lookupProxy) {\n        CommonStorage._setOwner(owner);\n        CommonStorage._setFactory(factory);\n        CommonStorage._setLookupProxy(lookupProxy);\n\n        // Setup supported interfaces\n        CommonStorage._setSupportedInterface(type(IERC165).interfaceId, true);\n        CommonStorage._setSupportedInterface(type(IERC173).interfaceId, true);\n    }\n\n    /// @inheritdoc\tUseLookup\n    function _implementation(\n        bytes4 _signature\n    ) internal view override returns (address implementation) {\n        address lookupProxyAddress = CommonStorage._getLookupProxy();\n        implementation = ILookup(lookupProxyAddress).getImplementation(\n            _signature,\n            IMPL_KEY\n        );\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}