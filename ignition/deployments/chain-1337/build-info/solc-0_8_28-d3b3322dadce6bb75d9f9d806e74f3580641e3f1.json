{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-d3b3322dadce6bb75d9f9d806e74f3580641e3f1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/upgrade/ProxyAdmin.sol": "project/contracts/upgrade/ProxyAdmin.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "project/contracts/common/Context.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title Context\n/// @author AdeThorMiwa\n/// @notice This contract is an abstract base contract that provides\n///         commonly used functions for accessing message information from the current context.\n/// @dev It is intended to be inherited by other contracts that need access to\n///      `msg.sender`, `msg.data`, `msg.sig`, and `msg.value`.\nabstract contract Context {\n    /// @dev Returns the message sender address from the current context.\n    /// @return msgSender The address of the message sender.\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    /// @dev Returns the message value (in wei) of the current context.\n    /// @return msgValue The value of the message in wei.\n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}\n"
      },
      "project/contracts/common/ERC1967Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {Proxy} from \"./Proxy.sol\";\nimport {ERC1967Upgrade} from \"./ERC1967Upgrade.sol\";\n\n/// @title ERC1967 Proxy\n/// @notice Implements a proxy contract based on the ERC1967 upgradeable proxy standard.\n/// @dev This contract acts as a proxy for delegating calls to an implementation contract.\n///      It supports upgrades using the ERC1967 upgrade mechanism.\nabstract contract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /// @dev Initializes an ERC1967 proxy with a given implementation contract and optional initialization data.\n    ///\n    /// Deploys the proxy and calls the `_upgradeToAndCall` function of the ERC1967Upgrade\n    /// contract to set the initial implementation and optionally execute data.\n    ///\n    /// Requirements:\n    /// - `_logic` must be a non-zero address.\n    constructor(address _logic, bytes memory _data) payable {\n        assert(\n            _IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _upgradeToAndCall(_logic, _data);\n    }\n\n    /// @dev Returns the current implementation address stored in this proxy.\n    ///\n    /// This function is an internal implementation detail and should generally not be used\n    /// directly by user applications.\n    function _implementation()\n        internal\n        view\n        virtual\n        override\n        returns (address impl)\n    {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
      },
      "project/contracts/common/ERC1967Upgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity 0.8.28;\n\nimport {StorageSlot} from \"../libs/StorageSlot.sol\";\nimport {CheckAddress} from \"../libs/CheckAddress.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {NotContractAddress, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\n\n/// @dev This abstract contract provides functionalities for managing storage slots\n/// used by the ERC1967 Upgradeable Proxy standard (EIP-1967).\n/// It includes functions for getting and setting the implementation address\n/// and the admin address.\n/// _Available since v4.1._\n/// @custom:oz-upgrades-unsafe-allow delegatecall\nabstract contract ERC1967Upgrade {\n    using Address for address;\n    using CheckAddress for address;\n\n    /// @dev Storage slot with the address of the current implementation.\n    /// This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev Emitted when the admin account has changed.\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\n\n    /// @dev Emitted when the implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev Perform implementation upgrade\n    /// Emits an {Upgraded} event.\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /// @dev Perform implementation upgrade with additional setup call.\n    /// Emits an {Upgraded} event.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0) {\n            newImplementation.functionDelegateCall(data);\n        }\n    }\n\n    /// @notice Changes the admin of the proxy.\n    /// @dev Emits an {AdminChanged} event.\n    function _changeAdmin(address newAdmin) internal {\n        _setAdmin(newAdmin);\n        emit AdminChanged(_getAdmin(), newAdmin);\n    }\n\n    /// @dev Returns the current implementation address.\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /// @dev Returns the current admin.\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /// @dev Stores a new address in the EIP1967 admin slot.\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0))\n            revert ZeroAddressNotAllowed(\"ADMIN_ADDRESS\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /// @dev Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        if (!newImplementation.hasContractCode())\n            revert NotContractAddress(newImplementation);\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n}\n"
      },
      "project/contracts/common/Ownable.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport {IERC173} from \"../interface/IERC173.sol\";\n\nimport {UnauthorizedAccount, ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\nimport {Context} from \"./Context.sol\";\n\n/// @title Ownable\n/// @author AdeThorMiwa\n/// @notice This contract implements the Ownable standard, allowing for the\n///         management of a contract's owner.\n/// @dev This implementation is based on the EIP-173 standard: https://eips.ethereum.org/EIPS/eip-173\nabstract contract Ownable is Context, IERC173 {\n    /// @dev The address of the current contract owner.\n    address private _owner;\n\n    /// @dev A modifier that restricts function execution to the contract owner.\n    modifier onlyOwner() {\n        if (_msgSender() != _getOwner())\n            revert UnauthorizedAccount(_msgSender(), \"NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new account (`_newOwner`).\n    /// @dev This function can only be called by the current contract owner.\n    ///         Reverts if the new owner is the zero address.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        if (_newOwner == address(0)) revert ZeroAddressNotAllowed(\"NEW_OWNER\");\n        _transferOwnership(_newOwner);\n    }\n\n    /// @notice Renounces ownership of the contract by transferring it to the zero address.\n    /// @dev This function can only be called by the current contract owner.\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return address The address of the current owner.\n    function owner() external view override returns (address) {\n        return _getOwner();\n    }\n\n    /// @notice Transfers ownership of the contract to a new account Â (`_newOwner`).\n    /// @dev This is an internal function, not meant to be called directly.\n    ///      Emits an `OwnershipTransferred` event after ownership is transferred.\n    /// @param _newOwner The address of the new owner.\n    function _transferOwnership(address _newOwner) internal virtual {\n        address _previousOwner = _getOwner();\n        _owner = _newOwner;\n        emit OwnershipTransferred(_previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the address of the current contract owner.\n    /// @dev This is an internal function, not meant to be called directly.\n    /// @return address The address of the current owner.\n    function _getOwner() internal view virtual returns (address) {\n        return _owner;\n    }\n}\n"
      },
      "project/contracts/common/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.28;\n\n/// @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n///       instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n///       be specified by overriding the virtual {_implementation} function.\n///       Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n///       different contract through the {_delegate} function.\n///       The success and return data of the delegated call will be returned back to the caller of the proxy.\nabstract contract Proxy {\n    /// @dev Fallback function that delegates calls to the address returned by `_implementation()`.\n    ///      Will run if call data is empty.\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /// @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n    ///     function in the contract matches the call data.\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /// @dev Delegates the current call to the address returned by `_implementation()`.\n    ///     This function does not return to its internall call site, it will return directly to the external caller.\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /// @notice Delegates the current call to `implementation`.\n    /// @dev This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n    ///      call, or as part of the Solidity `fallback` or `receive` functions.\n    ///      If overriden should call `super._beforeFallback()`.\n    // solhint-disable-next-line no-empty-blocks\n    function _beforeFallback() internal virtual {}\n\n    /// @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n    ///      and {_fallback} should delegate.\n    function _implementation() internal view virtual returns (address);\n}\n"
      },
      "project/contracts/interface/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title IERC173: Contract Ownership\n/// @author AdeThorMiwa\n/// @notice Interface for the ERC-173 Contract Ownership Standard.\n/// @dev See https://eips.ethereum.org/EIPS/eip-173 for more details.\ninterface IERC173 {\n    /// @dev Emitted when ownership of the contract is transferred.\n    /// @param previousOwner The address of the previous owner.\n    /// @param newOwner The address of the new owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Transfers ownership of the contract to a new address.\n    /// @dev Setting `newOwner` to the zero address renounces ownership.\n    /// @param _newOwner The address of the new owner.\n    function transferOwnership(address _newOwner) external;\n\n    /// @dev Returns the address of the current contract owner.\n    /// @return owner The address of the contract owner.\n    function owner() external view returns (address);\n}\n"
      },
      "project/contracts/libs/CheckAddress.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckAddress Library\n/// @author AdeThorMiwa\n/// @notice Provides utility functions for address type, particularly to check if an address is a contract.\n/// @dev This library contains a function to determine if an address has associated contract code.\nlibrary CheckAddress {\n    /// @dev Checks if an address has associated contract code.\n    /// @param _address The address to check for contract code.\n    /// @return bool indicating whether the address has contract code.\n    function hasContractCode(address _address) internal view returns (bool) {\n        uint256 _codeSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _codeSize := extcodesize(_address)\n        }\n        return _codeSize > 0;\n    }\n}\n"
      },
      "project/contracts/libs/CheckCallResult.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title CheckCallResult Library\n/// @author AdeThorMiwa\n/// @notice Provides a utility function to verify the result of a low-level call and revert if it fails.\n/// @dev This library contains a function to verify the success of a low-level call and handle the returned data or revert with an error message.\nlibrary CheckCallResult {\n    /// @dev Verifies the result of a low-level call.\n    /// @param _success A boolean indicating the success of the call.\n    /// @param _returnData The data returned from the call.\n    /// @param _errMessage The error message to revert with if the call failed and no return data is provided.\n    /// @return bytes The data returned from the call if it was successful.\n    function verifyCallResult(\n        bool _success,\n        bytes memory _returnData,\n        string memory _errMessage\n    ) internal pure returns (bytes memory) {\n        if (_success) {\n            return _returnData;\n        } else {\n            if (_returnData.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returnDataSize := mload(_returnData)\n                    revert(add(32, _returnData), returnDataSize)\n                }\n            } else {\n                revert(_errMessage);\n            }\n        }\n    }\n}\n"
      },
      "project/contracts/libs/StorageSlot.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\n/// @title StorageSlot Library\n/// @author AdeThorMiwa\n/// @notice Library for managing value storage slots\n/// @dev Provides functions to work with specific storage slots. Useful for reading and writing to contract storage slots directly.\n// solhint-disable no-inline-assembly\nlibrary StorageSlot {\n    /// @dev Struct to represent an address storage slot.\n    struct AddressSlot {\n        // The address value stored at the slot.\n        address value;\n    }\n\n    /// @notice Returns an `AddressSlot` with member `value` located at `slot`.\n    /// @param slot The storage slot to read from.\n    /// @return r The `AddressSlot` with the value located at `slot`.\n    function getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
      },
      "project/contracts/upgrade/ProxyAdmin.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {CheckCallResult} from \"../libs/CheckCallResult.sol\";\n\nimport {ZeroAddressNotAllowed} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../common/Ownable.sol\";\nimport {UpgradeableProxy} from \"./UpgradeableProxy.sol\";\n\n/// @title ProxyAdmin Contract\n/// @author AdeThorMiwa\n/// @notice This contract manages the upgradeability and administration of proxy contracts.\n/// @dev It allows the owner to change the proxy admin, upgrade the proxy implementation, and perform upgrade and call operations.\ncontract ProxyAdmin is Ownable {\n    using CheckCallResult for bool;\n\n    /// @dev Instantiates ProxyAdmin and explicityl sets the owner.\n    /// @param owner_ The address of the owner.\n    constructor(address owner_) {\n        if (owner_ == address(0)) revert ZeroAddressNotAllowed(\"OWNER\");\n        _transferOwnership(owner_);\n    }\n\n    /// @dev Upgrades `proxy` to `implementation`.\n    /// Requirements:\n    /// - This contract must be the admin of `proxy`.\n    /// @param proxy The address of the `UpgradeableProxy` contract.\n    /// @param implementation The address of the new implementation.\n    function upgrade(\n        UpgradeableProxy proxy,\n        address implementation\n    ) external onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /// @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n    /// See {UpgradeableProxy-upgradeToAndCall}.\n    /// Requirements:\n    /// - This contract must be the admin of `proxy`.\n    /// @param proxy The address of the `UpgradeableProxy` contract.\n    /// @param implementation The address of the new implementation.\n    /// @param data The data to call the new implementation with.\n    function upgradeAndCall(\n        UpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) external payable onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n\n    /// @dev Changes the admin of `proxy` to `newAdmin`.\n    /// Requirements:\n    /// - This contract must be the current admin of `proxy`.\n    /// @param proxy The address of the `UpgradeableProxy` contract.\n    /// @param newAdmin The address of the new admin.\n    function changeProxyAdmin(\n        UpgradeableProxy proxy,\n        address newAdmin\n    ) external onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /// @dev Returns the current admin address of `proxy`.\n    /// Requirements:\n    /// - This contract must be the admin of `proxy`.\n    /// @param proxy The address of the `UpgradeableProxy` contract.\n    /// @return The address of the current admin.\n    function getProxyAdmin(\n        UpgradeableProxy proxy\n    ) external view returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"f851a440\"\n        );\n        success.verifyCallResult(returndata, \"PROXY_ADMIN: CALL_FAILED\");\n        return abi.decode(returndata, (address));\n    }\n\n    /// @dev Returns the current implementation address of `proxy`.\n    /// Requirements:\n    /// - This contract must be the admin of `proxy`.\n    /// @param proxy The address of the `UpgradeableProxy` contract.\n    /// @return The address of the current implementation.\n    function getProxyImplementation(\n        UpgradeableProxy proxy\n    ) external view returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"5c60da1b\"\n        );\n\n        success.verifyCallResult(returndata, \"PROXY_ADMIN: CALL_FAILED\");\n        return abi.decode(returndata, (address));\n    }\n}\n"
      },
      "project/contracts/upgrade/UpgradeableProxy.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.28;\n\nimport {ZeroAddressNotAllowed, ActionRejected, InvalidInputData} from \"../utils/Errors.sol\";\nimport {ERC1967Proxy} from \"../common/ERC1967Proxy.sol\";\n\n/// @title UpgradeableProxy Contract\n/// @author AdeThorMiwa\n/// @notice This contract implements an upgradeable proxy that uses the ERC1967 standard.\n/// @dev It includes functions to upgrade the implementation and manage the admin role.\nabstract contract UpgradeableProxy is ERC1967Proxy {\n    /// @dev Modifier used internally to delegate the call to the implementation unless the sender is the admin.\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /// @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n    ///     Optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n    /// @param _logic The address of the initial implementation.\n    /// @param admin_ The address of the admin.\n    constructor(\n        address _logic,\n        address admin_\n    ) ERC1967Proxy(_logic, bytes(\"\")) {\n        assert(\n            _ADMIN_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _changeAdmin(admin_);\n    }\n\n    /// @dev Returns the current admin address.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-getProxyAdmin}\n    /// TIP: To get this value, clients can read directly from the storage slot specified by EIP1967 using the `eth_getStorageAt` RPC call.\n    /// @return admin_ The address of the current admin.\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /// @dev Returns the current implementation address.\n    /// Requirements:\n    /// - Only the admin can call this function.\n    /// TIP: To get this value, clients can read directly from the storage slot specified by EIP1967 using the `eth_getStorageAt` RPC call.\n    /// @return implementation_ The address of the current implementation.\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementation_)\n    {\n        implementation_ = _implementation();\n    }\n\n    /// @dev Changes the admin of the proxy to `newAdmin`.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-FactoryProxyAdmin}.\n    /// - `newAdmin` cannot be the zero address.\n    /// Emits an {AdminChanged} event.\n    /// @param newAdmin The address of the new admin.\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        if (address(newAdmin) == address(0))\n            revert ZeroAddressNotAllowed(\"NEW_ADMIN\");\n        _changeAdmin(newAdmin);\n    }\n\n    /// @dev Upgrade the implementation of the proxy to `newImplementation`.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-upgrade}.\n    /// - `newImplementation` cannot be the zero address.\n    /// @param newImplementation The address of the new implementation.\n    function upgradeTo(address newImplementation) external ifAdmin {\n        if (address(newImplementation) == address(0))\n            revert ZeroAddressNotAllowed(\"IMPLEMENTATION\");\n        _upgradeToAndCall(newImplementation, bytes(\"\"));\n    }\n\n    /// @dev Upgrade the implementation of the proxy to `newImplementation` and call a function from the new implementation.\n    /// Requirements:\n    /// - Only the admin can call this function. See {FactoryProxyAdmin-upgradeAndCall}.\n    /// - `newImplementation` cannot be the zero address.\n    /// @param newImplementation The address of the new implementation.\n    /// @param data The data to call the new implementation with.\n\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes calldata data\n    ) external payable ifAdmin {\n        if (data.length == 0) revert InvalidInputData(\"data\", \"ZERO_BYTES\");\n        if (address(newImplementation) == address(0))\n            revert ZeroAddressNotAllowed(\"IMPLEMENTATION\");\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    /// @dev Ensures the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n    /// Requirements:\n    /// - If the sender is the admin, revert with `ActionRejected`.\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin())\n            revert ActionRejected(\"UPGRADABLE_PROXY: ADMIN_FALLBACK\");\n        super._beforeFallback();\n    }\n}\n"
      },
      "project/contracts/utils/Errors.sol": {
        "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\n/// @title Custom Errors for Smart Contract\n/// @author AdeThorMiwa\n/// @dev This contract defines custom errors used throughout the system to provide detailed revert reasons.\n\n/// @notice Emitted when an account is unauthorized.\n/// @param account The unauthorized account address.\n/// @param message The error message.\nerror UnauthorizedAccount(address account, string message);\n\n/// @notice Emitted when a zero address is not allowed.\n/// @param message The error message.\nerror ZeroAddressNotAllowed(string message);\n\n/// @notice Emitted when a target address is not a contract.\n/// @param target The target address.\nerror NotContractAddress(address target);\n\n/// @notice Emitted when an action is rejected.\n/// @param action The action that was rejected.\nerror ActionRejected(string action);\n\n/// @notice Emitted when input data is invalid.\n/// @param input The invalid input.\n/// @param message The error message.\nerror InvalidInputData(string input, string message);\n\n/// @notice Emitted when the stash limit is reached.\n/// @param owner The account owner address.\n/// @param limit The limit reached.\nerror StashLimitReached(address owner, uint16 limit);\n\n/// @notice Emitted when a lookup implementation is invalid.\n/// @param implementation The implementation address.\n/// @param signature The function signature.\nerror InvalidLookupImplementation(address implementation, bytes4 signature);\n\n/// @notice Emitted when attempting to replace an immutable implementation.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableImplementationReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when the initialization call data is empty.\nerror EmptyInitCallData();\n\n/// @notice Emitted when a facet selector already exists.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror FacetSelectorExists(address facet, bytes4 selector);\n\n/// @notice Emitted when a facet function is invalid.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror InvalidFacetFunction(address facet, bytes4 selector);\n\n/// @notice Emitted when the count of function selectors is invalid.\n/// @param count The count of function selectors.\nerror InvalidFuncSelectorsCount(uint256 count);\n\n/// @notice Emitted when a facet contract is invalid.\n/// @param contractAddress The invalid facet contract address.\nerror InvalidFacetContract(address contractAddress);\n\n/// @notice Emitted when attempting to replace an immutable function.\n/// @param facet The facet address.\n/// @param selector The function selector.\nerror ImmutableFunctionReplacementError(address facet, bytes4 selector);\n\n/// @notice Emitted when an implementation lock key is invalid.\n/// @param key The invalid lock key.\nerror InvalidImplementationLockKey(bytes8 key);\n\n/// @notice Emitted when there is not enough balance for a transfer.\n/// @param account The account initiating the transfer.\n/// @param recipient The recipient of the transfer.\n/// @param balance The current balance of the account.\n/// @param amount The amount to be transferred.\n/// @param token The address of the token contract.\nerror NotEnoughBalance(\n    address account,\n    address recipient,\n    uint256 balance,\n    uint256 amount,\n    address token\n);\n\n/// @notice Emitted when the message value is invalid.\n/// @param message The error message.\nerror InvalidMessageValue(string message);\n\n/// @notice Emitted when a token contract address is invalid.\n/// @param token The invalid token contract address.\nerror InvalidTokenContractAddress(address token);\n\n/// @notice Emitted when the withdrawal amount is invalid.\n/// @param amount The withdrawal amount.\nerror InvalidWithdrawalAmount(uint256 amount);\n\n/// @notice Emitted when the withdrawal recipient is invalid.\n/// @param recipient The recipient address.\nerror InvalidWithdrawalRecipient(address recipient);\n"
      }
    }
  }
}